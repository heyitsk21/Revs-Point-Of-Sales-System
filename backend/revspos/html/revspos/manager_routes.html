<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>revspos.manager_routes API documentation</title>
<meta name="description" content="This module defines RESTful API resources for managing menu items, orders, employee information, and other related operations in the RevsPos â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>revspos.manager_routes</code></h1>
</header>
<section id="section-intro">
<p>This module defines RESTful API resources for managing menu items, orders, employee information, and other related operations in the RevsPos application.</p>
<p>It imports necessary modules from Flask, Flask-RESTx, and SQLAlchemy.</p>
<h2 id="classes">Classes</h2>
<ul>
<li>CompleteOrder: Defines a resource for marking an order as completed.</li>
<li>GetInProgressOrders: Defines a resource for retrieving in-progress orders.</li>
<li>Employee: Defines a resource for retrieving employee information.</li>
<li>MenuItems: Defines a resource for managing menu items.</li>
<li>Ingredients: Defines a resource for managing ingredients.</li>
<li>MenuItemIngredients: Defines a resource for managing ingredients for menu items.</li>
<li>MenuItemCustomizations: Defines a resource for managing customizations for menu items.</li>
<li>OrderHistory: Defines a resource for managing order history.</li>
<li>OrderStatusCompleted: Defines API routes for updating the status of completed orders managed by managers.</li>
<li>OrderStatusInprogress: Defines API routes for updating the status of in-progress orders managed by managers.</li>
<li>OrderStatusDeleted: Defines API routes for updating the status of deleted orders managed by managers.</li>
<li>OrderStatusCanceled: Defines API routes for updating the status of canceled orders managed by managers.</li>
<li>RestockAll: Defines API routes for restocking all ingredients below the recommended amount.</li>
<li>RestockSome: Defines API routes for restocking specified ingredients below the recommended amount.</li>
<li>RestockByLocation: Defines API routes for restocking ingredients below the recommended amount in a specified location.</li>
<li>GenerateProductUsage: Defines API routes for generating a product usage report (ingredients' change in inventory amounts over a period of time).</li>
<li>GenerateSalesReport: Defines API routes for generating a sales report (menu items' change in sale over a period of time).</li>
<li>GenerateExcessReport: Defines API routes for generating an excess report (menu items' that have ingredients that have sold less than 10% over a period of time).</li>
<li>GenerateRestockReport: Defines API routes for generating a restock report (ingredients that have less than the their minimum amount).</li>
<li>GenerateOrderTrend: Defines API routes for generating an order trend report (top ten menu items ordered together).</li>
</ul>
<h2 id="attributes">Attributes</h2>
<ul>
<li>api: Represents the Flask-RESTx API instance.</li>
<li>db: Represents the database instance.</li>
</ul>
<h2 id="models">Models</h2>
<ul>
<li>AddMenuItem_model: Defines a model for adding a menu item.</li>
<li>UpdateMenuItem_model: Defines a model for updating a menu item.</li>
<li>DeleteMenuItem_model: Defines a model for deleting a menu item.</li>
<li>AddIngredient_model: Defines a model for adding an ingredient.</li>
<li>UpdateIngredient_model: Defines a model for updating an ingredient.</li>
<li>DeleteIngredient_model: Defines a model for deleting an ingredient.</li>
<li>GetIngredientsFromMenuItem_model: Defines a model for retrieving ingredients from a menu item.</li>
<li>AddIngredientToMenuItem_model: Defines a model for adding an ingredient to a menu item.</li>
<li>DeleteIngredientFromMenuItem_model: Defines a model for deleting an ingredient from a menu item.</li>
<li>GetCustomizationsFromMenuItem_model: Defines a model for retrieving customizations from a menu item.</li>
<li>AddCustomizationToMenuItem_model: Defines a model for adding a customization to a menu item.</li>
<li>DeleteCustomizationFromMenuItem_model: Defines a model for deleting a customization from a menu item.</li>
<li>UpdateOrder_model: Defines a model for updating an order.</li>
<li>DeleteOrder_model: Defines a model for deleting an order.</li>
<li>OrderStatus_model: Defines a model for representing order status.</li>
<li>RestockSome_model: Defines a model for restocking some ingredients.</li>
<li>RestockByLocation_model: Defines a model for restocking ingredients by location.</li>
<li>GenerateExcessReport_model: Defines a model for generating an excess report.</li>
<li>GenerateProductUsage_model: Defines a model for generating a product usage report.</li>
<li>GenerateSalesReport_model: Defines a model for generating a sales report.</li>
<li>GenerateOrderTrend_model: Defines a model for generating an order trend report.</li>
<li>CompleteOrder_model: Defines a model for marking an order as completed.</li>
</ul>
<h2 id="methods">Methods</h2>
<ul>
<li>post: Handles HTTP POST requests.</li>
<li>get: Handles HTTP GET requests.</li>
<li>put: Handles HTTP PUT requests.</li>
<li>delete: Handles HTTP DELETE requests.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module defines RESTful API resources for managing menu items, orders, employee information, and other related operations in the RevsPos application.

It imports necessary modules from Flask, Flask-RESTx, and SQLAlchemy.

Classes:
    - CompleteOrder: Defines a resource for marking an order as completed.
    - GetInProgressOrders: Defines a resource for retrieving in-progress orders.
    - Employee: Defines a resource for retrieving employee information.
    - MenuItems: Defines a resource for managing menu items.
    - Ingredients: Defines a resource for managing ingredients.
    - MenuItemIngredients: Defines a resource for managing ingredients for menu items.
    - MenuItemCustomizations: Defines a resource for managing customizations for menu items.
    - OrderHistory: Defines a resource for managing order history.
    - OrderStatusCompleted: Defines API routes for updating the status of completed orders managed by managers.
    - OrderStatusInprogress: Defines API routes for updating the status of in-progress orders managed by managers.
    - OrderStatusDeleted: Defines API routes for updating the status of deleted orders managed by managers.
    - OrderStatusCanceled: Defines API routes for updating the status of canceled orders managed by managers.
    - RestockAll: Defines API routes for restocking all ingredients below the recommended amount.
    - RestockSome: Defines API routes for restocking specified ingredients below the recommended amount.
    - RestockByLocation: Defines API routes for restocking ingredients below the recommended amount in a specified location.
    - GenerateProductUsage: Defines API routes for generating a product usage report (ingredients&#39; change in inventory amounts over a period of time).
    - GenerateSalesReport: Defines API routes for generating a sales report (menu items&#39; change in sale over a period of time).
    - GenerateExcessReport: Defines API routes for generating an excess report (menu items&#39; that have ingredients that have sold less than 10% over a period of time).
    - GenerateRestockReport: Defines API routes for generating a restock report (ingredients that have less than the their minimum amount).
    - GenerateOrderTrend: Defines API routes for generating an order trend report (top ten menu items ordered together).
    
Attributes:
    - api: Represents the Flask-RESTx API instance.
    - db: Represents the database instance.

Models:
    - AddMenuItem_model: Defines a model for adding a menu item.
    - UpdateMenuItem_model: Defines a model for updating a menu item.
    - DeleteMenuItem_model: Defines a model for deleting a menu item.
    - AddIngredient_model: Defines a model for adding an ingredient.
    - UpdateIngredient_model: Defines a model for updating an ingredient.
    - DeleteIngredient_model: Defines a model for deleting an ingredient.
    - GetIngredientsFromMenuItem_model: Defines a model for retrieving ingredients from a menu item.
    - AddIngredientToMenuItem_model: Defines a model for adding an ingredient to a menu item.
    - DeleteIngredientFromMenuItem_model: Defines a model for deleting an ingredient from a menu item.
    - GetCustomizationsFromMenuItem_model: Defines a model for retrieving customizations from a menu item.
    - AddCustomizationToMenuItem_model: Defines a model for adding a customization to a menu item.
    - DeleteCustomizationFromMenuItem_model: Defines a model for deleting a customization from a menu item.
    - UpdateOrder_model: Defines a model for updating an order.
    - DeleteOrder_model: Defines a model for deleting an order.
    - OrderStatus_model: Defines a model for representing order status.
    - RestockSome_model: Defines a model for restocking some ingredients.
    - RestockByLocation_model: Defines a model for restocking ingredients by location.
    - GenerateExcessReport_model: Defines a model for generating an excess report.
    - GenerateProductUsage_model: Defines a model for generating a product usage report.
    - GenerateSalesReport_model: Defines a model for generating a sales report.
    - GenerateOrderTrend_model: Defines a model for generating an order trend report.
    - CompleteOrder_model: Defines a model for marking an order as completed.

Methods:
    - post: Handles HTTP POST requests.
    - get: Handles HTTP GET requests.
    - put: Handles HTTP PUT requests.
    - delete: Handles HTTP DELETE requests.

&#34;&#34;&#34;

from flask import request, jsonify
from flask_restx import  Resource, fields
from sqlalchemy import text
from sqlalchemy.exc import ObjectNotExecutableError
from .api_master import api, db

AddMenuItem_model = api.model(&#39;AddMenuItem&#39;, {&#34;category&#34;:fields.Integer(required=True), &#34;itemname&#34;:fields.String(required=True, min_length=3, max_length=30), &#34;price&#34;:fields.Float(required=True)})
UpdateMenuItem_model = api.model(&#39;UpdateMenuItem&#39;, {&#34;menuid&#34;:fields.Integer(required=True), &#34;itemname&#34;:fields.String(min_length=3, max_length=30), &#34;price&#34;:fields.Float})
DeleteMenuItem_model = api.model(&#39;DeleteMenuItem&#39;, {&#34;menuid&#34;:fields.Integer(required=True)})

AddIngredient_model = api.model(&#39;AddIngredient&#39;, { &#34;ingredientname&#34;:fields.String(min_length=3,max_length=30,required=True), &#34;count&#34;:fields.Integer(required=True), &#34;ppu&#34;:fields.Float(required=True), &#34;minamount&#34;:fields.Integer(required=True), &#34;location&#34;:fields.String(required=True,min_length=6,max_length=7),&#34;recommendedamount&#34;:fields.Integer(required=True),&#34;caseamount&#34;:fields.Integer(required=True)})
UpdateIngredient_model = api.model(&#39;UpdateIngredient&#39;, {&#34;ingredientid&#34;:fields.Integer(required=True), &#34;ingredientname&#34;:fields.String(min_length=3,max_length=30), &#34;count&#34;:fields.Integer, &#34;ppu&#34;:fields.Float, &#34;minamount&#34;:fields.Integer, &#34;location&#34;:fields.String(min_length=6,max_length=7),&#34;recommendedamount&#34;:fields.Integer,&#34;caseamount&#34;:fields.Integer})
DeleteIngredient_model = api.model(&#39;DeleteIngredient&#39;, {&#34;ingredientid&#34;:fields.Integer(required=True), &#34;count&#34;:fields.Integer(required=True)})

GetIngredientsFromMenuItem_model = api.model(&#39;GetIngredientsFromMenuItem&#39;, {&#34;menuitemid&#34;:fields.Integer(required=True)})
AddIngredientToMenuItem_model = api.model(&#39;AddIngredientToMenuItem&#39;, {&#34;menuitemid&#34;:fields.Integer(required=True), &#34;ingredientid&#34;:fields.Integer(required=True)})
DeleteIngredientFromMenuItem_model = api.model(&#39;DeleteIngredientFromMenuItem&#39;, {&#34;menuitemid&#34;:fields.Integer(required=True), &#34;ingredientid&#34;:fields.Integer(required=True)})

GetCustomizationsFromMenuItem_model = api.model(&#39;GetCustomizationsFromMenuItem&#39;, {&#34;menuitemid&#34;:fields.Integer(required=True)})
AddCustomizationToMenuItem_model = api.model(&#39;AddCustomizationToMenuItem&#39;, {&#34;menuitemid&#34;:fields.Integer(required=True), &#34;customizationid&#34;:fields.Integer(required=True)})
DeleteCustomizationFromMenuItem_model = api.model(&#39;DeleteCustomizationFromMenuItem&#39;, {&#34;menuitemid&#34;:fields.Integer(required=True), &#34;customizationid&#34;:fields.Integer(required=True)})

# GetOrder_model = api.model(&#39;GetOrder&#39;, {&#34;orderid&#34;:fields.Integer, &#34;numberOfOutputs&#34;:fields.Integer})
UpdateOrder_model = api.model(&#39;UpdateOrder&#39;, {&#34;orderid&#34;:fields.Integer(required=True), &#34;customername&#34;:fields.String(min_length=3, max_length=25), &#34;baseprice&#34;:fields.Float, &#34;employeeid&#34;:fields.Integer})
DeleteOrder_model = api.model(&#39;DeleteOrder&#39;, {&#34;orderid&#34;:fields.Integer(required=True)})

OrderStatus_model = api.model(&#39;OrderStatusComplete&#39;, {&#34;orderid&#34;:fields.Integer(required=True)})

RestockSome_model = api.model(&#39;RestockSome&#39;, {&#39;ingredientids&#39;: fields.List(fields.Integer,required=True)})
RestockByLocation_model = api.model(&#39;RestockByLocation&#39;, {&#39;location&#39;:fields.String(min_length=6,max_length=7,required=True)})

GenerateExcessReport_model = api.model(&#39;GenerateExcessReport&#39;,{&#34;startdate&#34;: fields.Date(required=True)})
GenerateProductUsage_model = api.model(&#39;GenerateProductUsage&#39;,{&#34;startdate&#34;: fields.Date(required=True), &#34;enddate&#34;: fields.Date(required=True)})
GenerateSalesReport_model = api.model(&#39;GenerateSalesReport&#39;,{&#34;startdate&#34;: fields.Date(required=True), &#34;enddate&#34;: fields.Date(required=True)})
GenerateOrderTrend_model = api.model(&#39;GenerateOrderTrend&#39;,{&#34;startdate&#34;: fields.Date(required=True), &#34;enddate&#34;: fields.Date(required=True)})

CompleteOrder_model = api.model(&#39;CompleteOrder&#39;,{&#34;orderid&#34;:fields.Integer(required=True)})


AddEmployee_model = api.model(&#39;AddEmployee&#39;, { &#34;employeeName&#34;:fields.String(required=True), &#34;employeeEmail&#34;:fields.String(required=True), &#34;isManager&#34;:fields.Boolean(required=True), &#34;salary&#34;:fields.Float(required=True), &#34;password&#34;:fields.String(required=True)})
UpdateEmployee_model = api.model(&#39;UpdateEmploy&#39;, {&#34;employeeid&#34;:fields.Integer(required=True), &#34;employeeName&#34;:fields.String(),&#34;employeeEmail&#34;:fields.String(required=True), &#34;isManager&#34;:fields.Boolean(), &#34;salary&#34;:fields.Float(), &#34;password&#34;:fields.String()})
DeleteEmployee_model = api.model(&#39;DeleteEmployee&#39;,{&#39;employeeid&#39;:fields.Integer(required=True)})

@api.route(&#39;/api/kitchen/completeorder&#39;)
class CompleteOrder(Resource):
    &#34;&#34;&#34;
    Resource for marking an order as completed.
    &#34;&#34;&#34;

    @api.expect(CompleteOrder_model, validate=True)
    def post(self):
        &#34;&#34;&#34;
        POST method for marking an order as completed.
        &#34;&#34;&#34;
        data = request.get_json()
        orderid = data.get(&#34;orderid&#34;)
        with db.engine.connect() as conn:
            conn.connection.cursor().execute(f&#34;UPDATE ORDERS SET ORDERSTAT = &#39;completed&#39; WHERE ORDERID = {orderid};&#34;)
            conn.connection.commit()
        

@api.route(&#39;/api/kitchen/getinprogressorders&#39;)
class GetInProgressOrders(Resource):
    &#34;&#34;&#34;
    Resource for retrieving in-progress orders.
    &#34;&#34;&#34;

    def get(self):
        &#34;&#34;&#34;
        GET method for retrieving in-progress orders.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(&#34;SELECT * FROM ORDERS WHERE ORDERSTAT = &#39;inprogress&#39; ORDER BY ORDERID;&#34;))
            orderlist = []
            for row in result:
                order = {}
                order[&#39;orderid&#39;] = row.orderid
                order[&#39;customername&#39;] = row.customername
                orderlist.append(order)
                menuitems = []
                menuresult = conn.execution_options(stream_results=True).execute(text(f&#34;SELECT menuitems.itemname, customizationID FROM orders JOIN ordermenuitems ON ordermenuitems.orderID = orders.orderID JOIN menuitems ON ordermenuitems.menuID = menuitems.menuID where orders.orderID = {row.orderid};&#34;))
                for row2 in menuresult:
                    menuitem = {}
                    menuitem[&#39;menuitemname&#39;] = row2.itemname   
                    if(row2.customizationid != None):
                        custresult = conn.execution_options(stream_results=True).execute(text(f&#34;SELECT customizationID,ingredients.ingredientname AS WantedCustimzation FROM ordermenuitems JOIN customizationordermenu ON ordermenuitems.customizationID = customizationordermenu.customizationordermenuID JOIN ingredients ON customizationordermenu.ingredientID = ingredients.ingredientID JOIN menuitems ON ordermenuitems.menuID = menuitems.menuID WHERE customizationid = {row2.customizationid};&#34;))
                        custs = []
                        for row3 in custresult:
                            custs.append(row3.wantedcustimzation)
                        menuitem[&#39;customizations&#39;] = custs
                    menuitems.append(menuitem)
                order[&#39;menuitems&#39;] = menuitems
            return jsonify(orderlist)
        


@api.route(&#39;/api/manager/employee&#39;)
class Employee(Resource):
    &#34;&#34;&#34;
    Resource for retrieving employee information.
    &#34;&#34;&#34;

    def get(self):
        &#34;&#34;&#34;
        GET method for retrieving employee information.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(&#34;select * from employee&#34;))
            employeelist = []
            for row in result:
                employeelist.append({&#34;employeeid&#34;:row.employeeid, &#34;employeename&#34;:row.employeename, &#34;ismanager&#34;:row.ismanager, &#34;salary&#34;:row.salary, &#34;password&#34;:row.password})
        return jsonify(employeelist)

    @api.expect(AddEmployee_model, validate=True)
    def post(self):
        &#34;&#34;&#34;
        POST method for adding a new employee.
        &#34;&#34;&#34;
        data = request.get_json()
        name = data.get(&#34;employeeName&#34;)
        email = data.get(&#34;employeeEmail&#34;)
        isManager = data.get(&#34;isManager&#34;)
        salary = data.get(&#34;salary&#34;)
        password = data.get(&#34;password&#34;)
        add_employee_query = text(&#34;INSERT INTO employee ( EmployeeName,employeeEmail, IsManager, Salary, Password)  VALUES (&#39;{inname}&#39;,&#39;{inemail}&#39;, {inismanager}, {insalary},&#39;{inpass}&#39;)&#34;.format(inname = name,inemail=email, inismanager=isManager, insalary=salary,inpass = password))
        
        with db.engine.connect() as conn:
            conn.execute(add_employee_query)
            conn.commit()
        #except Exception as e:
            # print(e)
            #return jsonify({&#34;message&#34;: &#34;Failed to add employee&#34;})
        
        return jsonify({&#34;message&#34;: &#34;Sucessfully added Employee&#34;})
    

    @api.expect(UpdateEmployee_model, validate=True)
    def put(self):
        &#34;&#34;&#34;
        PUT method for updating employee information.
        &#34;&#34;&#34;
        data = request.get_json()
        empid = data.get(&#34;employeeid&#34;)
        name = data.get(&#34;employeeName&#34;)
        email = data.get(&#34;employeeEmail&#34;)
        isManager = data.get(&#34;isManager&#34;)
        salary = data.get(&#34;salary&#34;)
        password = data.get(&#34;password&#34;)

        if(name == None and email == None and isManager == None and salary == None and password == None):
            return jsonify({&#34;message&#34;: &#34;No inputs entered. No query executed.&#34;})

        update_query = &#34;UPDATE employee SET &#34;
        if (name != None):
            update_query += &#34;employeeName = &#39;{inputname}&#39;,&#34;.format(inputname=name)
        if (email != None):
            update_query += &#34;employeeEmail = &#39;{inputemail}&#39;,&#34;.format(inputemail=email)
        if (isManager != None):
            update_query += &#34;ismanager = {inputisman},&#34;.format(inputisman=isManager)
        if (salary != None):
            update_query += &#34;salary = {inputsalary},&#34;.format(inputsalary=salary)
        if (password != None):
            update_query += &#34;password = &#39;{inputpassword}&#39;,&#34;.format(inputpassword=password)

        update_query = update_query[:-1]
        update_query += &#34; WHERE employeeid = {inputemployeeid}&#34;.format(inputemployeeid=empid)

        with db.engine.connect() as conn:
            conn.execute(text(update_query))
            conn.commit()
        return jsonify({&#34;message&#34;: &#34;successful update of employee&#34;})

    @api.expect(DeleteEmployee_model, validate=True)
    def delete(self):
        &#34;&#34;&#34;
        DELETE method for deleting an employee.
        &#34;&#34;&#34;
        employeeid = request.get_json().get(&#34;employeeid&#34;)

        delete_employee_query = &#34;DELETE FROM employee WHERE EmployeeID = {inputempid}&#34;.format(inputempid=employeeid)
        with db.engine.connect() as conn:
            conn.connection.cursor().execute(delete_employee_query)
            conn.connection.commit()
        
        return jsonify({&#34;message&#34;: &#34;Sucessfully deleted employee with employeeid = {inputempid}&#34;.format(inputempid=employeeid)})

@api.route(&#39;/api/manager/menuitems&#39;)
class MenuItems(Resource):
    &#34;&#34;&#34;
    Resource for retrieving menu item information.
    &#34;&#34;&#34;

    def get(self): #GetMenuItem
        &#34;&#34;&#34;
        GET method for retrieving menu item information.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(&#34;select * from menuitems&#34;))
            menuitemlist = []
            for row in result:
                menuitemlist.append({&#34;menuid&#34;:row.menuid, &#34;itemname&#34;:row.itemname, &#34;price&#34;:row.price, &#34;picturepath&#34;:row.picturepath})
        return jsonify(menuitemlist)
    
    @api.expect(AddMenuItem_model, validate=False)
    def post(self): #AddMenuItem
        &#34;&#34;&#34;
        POST method for creating menu item information.
        &#34;&#34;&#34;
        # print(&#34;GOT HERE&#34;)
        data = request.get_json()
        category = data.get(&#34;category&#34;)
        itemname = data.get(&#34;itemname&#34;)
        price = data.get(&#34;price&#34;)
        menuid = 0

        select_query = text(&#34;SELECT MENUID FROM MENUITEMS WHERE MENUID BETWEEN {lowerbound} AND {upperbound} ORDER BY MENUID DESC LIMIT 1;&#34;.format(lowerbound = category,upperbound = int(category) + 100))
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(select_query)
            for row in result:
                menuid = row.menuid + 1

        add_menu_item_query = text(&#34;INSERT INTO MenuItems (MenuID, ItemName, Price) VALUES ({inputmenuid}, &#39;{inputitemname}&#39;, {inputprice})&#34;.format(inputmenuid=menuid, inputitemname=itemname, inputprice=price))
        try:
            with db.engine.connect() as conn:
                conn.execute(add_menu_item_query)
                conn.commit()
        except Exception as e:
            # print(e)
            return jsonify({&#34;message&#34;: &#34;Failed to add menu item&#34;})
        
        return jsonify({&#34;message&#34;: &#34;Sucessfully added Menu item with menuid = {inputmenuid}&#34;.format(inputmenuid=menuid)})
    
    @api.expect(UpdateMenuItem_model, validate=True)
    def put(self): #UpdateMenuItem
        &#34;&#34;&#34;
        PUT method for updating menu item information.
        &#34;&#34;&#34;
        data = request.get_json()
        menuid = data.get(&#34;menuid&#34;)
        itemname = data.get(&#34;itemname&#34;)
        price = data.get(&#34;price&#34;)

        if (menuid == 0):
            return jsonify({&#34;message&#34;: &#34;No Menu Item ID entered. No query executed.&#34;})
        elif (itemname == &#34;string&#34; and price == 0):
            return jsonify({&#34;message&#34;: &#34;No inputs entered. No query executed.&#34;})
        
        update_query = &#34;UPDATE menuitems SET &#34;
        if (itemname != &#34;string&#34;):
            update_query += &#34;itemname = &#39;{inputnewname}&#39;,&#34;.format(inputnewname=itemname)
        if (price &gt; 0):
            update_query += &#34;price = {inputnewprice},&#34;.format(inputnewprice=price)

        update_query = update_query[:-1]
        update_query += &#34; WHERE menuid = {inputmenuidid}&#34;.format(inputmenuidid=menuid)

        with db.engine.connect() as conn:
            result = conn.execute(text(update_query))
            conn.commit()
        return jsonify({&#34;message&#34;: &#34;successful update of menu item with menuid = {inputmenuid}&#34;.format(inputmenuid=menuid)})

    @api.expect(DeleteMenuItem_model, validate=True)
    def delete(self): #DeleteMenuItem #TODO: need to do a check where the menuid actually exists first before doing queries. Success msg is wrongfully shown when deleting menuid that doesnt exist in the db
        &#34;&#34;&#34;
        DELETE method for deleting menu item information.
        &#34;&#34;&#34;
        menuid = request.get_json().get(&#34;menuid&#34;)

        delete_menuitemingredients_query = &#34;DELETE FROM menuitemIngredients WHERE MenuID = {inputmenuid}&#34;.format(inputmenuid=menuid)
        with db.engine.connect() as conn:
            conn.connection.cursor().execute(delete_menuitemingredients_query)
            conn.connection.commit()
        
        delete_menuitem_query = &#34;DELETE FROM menuitems WHERE MenuID = {inputmenuid}&#34;.format(inputmenuid=menuid)
        with db.engine.connect() as conn:
            conn.connection.cursor().execute(delete_menuitem_query)
            conn.connection.commit()
        
        return jsonify({&#34;message&#34;: &#34;Sucessfully deleted Menu item with menuid = {inputmenuid}&#34;.format(inputmenuid=menuid)})

@api.route(&#39;/api/manager/ingredients&#39;)
class Ingredients(Resource):
    &#34;&#34;&#34;
    Resource for retrieving ingredient information.
    &#34;&#34;&#34;

    def get(self): #GetIngredients
        &#34;&#34;&#34;
        GET method for retrieving ingredient information.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(&#34;select * from ingredients&#34;))
            menuitemlist = []
            for row in result:
                menuitemlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount,&#34;caseamount&#34;:row.caseamount})
        return jsonify(menuitemlist)
    
    @api.expect(AddIngredient_model, validate=True)
    def post(self): #AddIngredient
        &#34;&#34;&#34;
        POST method for creating menu item information.
        &#34;&#34;&#34;
        data = request.get_json()

        ingredientname = data.get(&#34;ingredientname&#34;)
        count = data.get(&#34;count&#34;)
        ppu = data.get(&#34;ppu&#34;)
        minamount = data.get(&#34;minamount&#34;)
        location = data.get(&#34;location&#34;)
        recommendedamount = data.get(&#34;recommendedamount&#34;)
        caseamount = data.get(&#34;caseamount&#34;)

        
        if (ingredientname == &#34;string&#34; or count == 0 or ppu == 0 or minamount == 0 or location == &#39;string&#39; or recommendedamount == 0 or caseamount == 0):
            return jsonify({&#34;message&#34;:&#34;failed to insert ingredient. Missing fields. All fields are required.&#34;})
        
        insert_query = text(&#34;INSERT INTO Ingredients (Ingredientname, Count, PPU, minamount, location, recommendedamount, caseamount) VALUES (&#39;{inputingredientname}&#39;, {inputcount}, {inputppu}, {inputminamount}, &#39;{inputlocation}&#39;, {inputrecamt}, {inputcaseamt})&#34;.format(inputingredientname=ingredientname,inputcount=count,inputppu=ppu, inputminamount=minamount,inputlocation=location,inputrecamt=recommendedamount,inputcaseamt=caseamount))
        with db.engine.connect() as conn:
            conn.execute(insert_query)
            conn.commit()
        return jsonify({&#34;message&#34;:&#34;Sucessfully inserted the ingredient with ingredientname = {inputingredientname}&#34;.format(inputingredientname=ingredientname)})

    @api.expect(UpdateIngredient_model, validate=True)
    def put(self): #UpdateIngredient
        &#34;&#34;&#34;
        PUT method for updating menu item information.
        &#34;&#34;&#34;
        data = request.get_json()
        ingredientid = data.get(&#34;ingredientid&#34;)
        newname = data.get(&#34;ingredientname&#34;)
        newcount = data.get(&#34;count&#34;)
        newppu = data.get(&#34;ppu&#34;)
        newminamount = data.get(&#34;minamount&#34;)
        newloc = data.get(&#34;location&#34;)
        newrecamt = data.get(&#34;recommendedamount&#34;)
        newcaseamt = data.get(&#34;caseamount&#34;)
        
        if (ingredientid == 0):
            return jsonify({&#34;message&#34;: &#34;No ingredientid entered. No query executed.&#34;})
        elif (newname == &#34;string&#34; and newcount == 0 and newppu == 0 and newminamount == 0 and newloc == &#34;string&#34; and newrecamt == 0 and newcaseamt == 0):
            return jsonify({&#34;message&#34;: &#34;No inputs entered. No query executed.&#34;})

        update_query = &#34;UPDATE ingredients SET &#34;
        if (newname != &#34;string&#34;):
            update_query += &#34;ingredientname = &#39;{inputnewname}&#39;,&#34;.format(inputnewname=newname)
        if (newcount &gt; 0):
            update_query += &#34;count = {inputnewcount},&#34;.format(inputnewcount=newcount)
        if (newppu &gt; 0):
            update_query += &#34;ppu = {inputnewppu},&#34;.format(inputnewppu=newppu)
        if (newminamount &gt; 0):
            update_query += &#34;minamount = {inputnewminamount},&#34;.format(inputnewminamount=newminamount)
        if (newloc != &#34;string&#34;):
            update_query += &#34;location = &#39;{inputloc}&#39;,&#34;.format(inputloc=newloc)
        if (newrecamt &gt; 0):
            update_query += &#34;recommendedamount = {inputrecamt},&#34;.format(inputrecamt=newrecamt)
        if (newcaseamt &gt; 0):
            update_query += &#34;caseamount = {inputcaseamt},&#34;.format(inputcaseamt=newcaseamt)
        
        update_query = update_query[:-1]
        update_query += &#34; WHERE IngredientID = {inputingredientid}&#34;.format(inputingredientid=ingredientid)
        try:
            with db.engine.connect() as conn:
                conn.execute(text(update_query))
                conn.commit()
                return jsonify({&#34;message&#34;: &#34;successful update of ingredient with ingredientid = {inputingredientid}&#34;.format(inputingredientid=ingredientid)})
        except ObjectNotExecutableError:
            return jsonify({&#34;message&#34;:&#34;failed to find ingredient with ingredientid = {inputingredientid}&#34;.format(inputingredientid=ingredientid)})
    
    @api.expect(DeleteIngredient_model, validate=True)
    def delete(self): #DeleteIngredient #TODO: FIX THIS ONE. THERE&#39;S A TON OF EXECUTES AND NO ERROR CHECKING, 
        &#34;&#34;&#34;
        DELETE method for deleting menu item information.
        &#34;&#34;&#34;
        data = request.get_json()
        ingredientid = data.get(&#34;ingredientid&#34;)
        count = data.get(&#34;count&#34;)

        delete_from_join_cmd = &#34;DELETE FROM MenuItemIngredients WHERE IngredientID = {inputingredientid}&#34;.format(inputingredientid=ingredientid)
        with db.engine.connect() as conn:
            conn.connection.cursor().execute(delete_from_join_cmd)
            conn.connection.commit()

        delete_ingredient_cmd = &#34;DELETE FROM Ingredients WHERE IngredientID = {inputingredientid}&#34;.format(inputingredientid=ingredientid)
        with db.engine.connect() as conn:
            conn.connection.cursor().execute(delete_ingredient_cmd)
            conn.connection.commit()

        negate_count = count * -1
        log_message = &#34;INGREDIENT COUNT SET TO 0: DELETED INGREDIENT WITH INGREDIENTID = {inputingredientid}&#34;.format(inputingredientid=ingredientid)

        insert_log_cmd = text(&#34;INSERT INTO InventoryLog (IngredientID, AmountChanged, LogMessage, LogDateTime) VALUES ({inputingredientid}, {inputnegate_count}, &#39;{inputlog_message}&#39;, NOW())&#34;.format(inputingredientid=ingredientid, inputnegate_count=negate_count, inputlog_message=log_message))
        try:         
            with db.engine.connect() as conn:
                conn.execute(insert_log_cmd)
                conn.commit()
            return jsonify({&#34;message&#34;: &#34;successful deletion of ingredient with ingredientid = {inputingredientid}&#34;.format(inputingredientid=ingredientid)})
        except ObjectNotExecutableError as e:
            return jsonify({&#34;message&#34;:&#34;failed to delete ingredient with ingredientid = {inputingredientid}&#34;.format(inputingredientid=ingredientid)})

@api.route(&#39;/api/manager/menuitemingredients&#39;)
class MenuItemIngredients(Resource):
    &#34;&#34;&#34;
    Resource for retrieving menuitem-ingredient join table information.
    &#34;&#34;&#34;
    @api.expect(GetIngredientsFromMenuItem_model, validate=True)
    def put(self): #GetIngredientFromMenuItem
        &#34;&#34;&#34;
        PUT method for retrieving ingredient information from a menu item.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
            result = conn.execution_options(stream_results=True).execute(text(&#34;SELECT Ingredients.IngredientID, Ingredients.IngredientName &#34; +
                &#34;FROM menuitems JOIN menuitemingredients ON menuitems.MenuID = menuitemingredients.MenuID &#34; +
                &#34;JOIN Ingredients ON menuitemingredients.IngredientID = Ingredients.IngredientID &#34; +
                &#34;WHERE menuitems.MenuID = {inputmenuitemid}&#34;.format(inputmenuitemid = menuitemid)))
            menuitemingredientslist = []
            for row in result:
                menuitemingredientslist.append({&#34;ingredientname&#34;:row.ingredientname, &#34;ingredientid&#34;:row.ingredientid})
        return jsonify(menuitemingredientslist)
    
    @api.expect(AddIngredientToMenuItem_model, validate=True)
    def post(self): #AddIngredientToMenuItem
        &#34;&#34;&#34;
        POST method for creating ingredient information for a menu item.
        &#34;&#34;&#34;
        menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
        ingredientid = request.get_json().get(&#34;ingredientid&#34;) 

        add_ingredient_query = &#34;INSERT INTO menuitemIngredients (MenuID, IngredientID) values ({inputmenuitemid},{inputingredientid})&#34;.format(inputmenuitemid = menuitemid, inputingredientid = ingredientid)
                   
        with db.engine.connect() as conn:
            result = conn.execute(text(add_ingredient_query)) #execution_options(stream_results=True).
            conn.commit()

            select_add_ingredient_query = &#34;SELECT * FROM menuitemingredients WHERE menuid = {inputmenuitemid}&#34;.format(inputmenuitemid = menuitemid)
            resultselect = conn.execution_options(stream_results=True).execute(text(select_add_ingredient_query))
            menuitemingredientslist = []
            for row in resultselect:
                menuitemingredientslist.append({&#34;menuid&#34;:row.menuid,&#34;ingredientid&#34;:row.ingredientid})
        return jsonify(menuitemingredientslist)
    
    @api.expect(DeleteIngredientFromMenuItem_model, validate=True)
    def delete(self): 
        &#34;&#34;&#34;
        DELETE method for deleting ingredient information from a menu item.
        &#34;&#34;&#34;
        menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
        ingredientid = request.get_json().get(&#34;ingredientid&#34;) 

        delete_ingredient_query = &#34;DELETE FROM menuitemIngredients WHERE MenuID={inputmenuitemid} AND ingredientID={inputingredientid}&#34;.format(inputmenuitemid = menuitemid, inputingredientid = ingredientid)

        with db.engine.connect() as conn:
            conn.connection.cursor().execute(delete_ingredient_query)
            conn.connection.commit()
            return jsonify({&#34;message&#34;:&#34;successfully deleted order with menuid = {inputmenuitemid} and ingredient = {inputingredientid}&#34;.format(inputmenuitemid = menuitemid, inputingredientid = ingredientid)})

@api.route(&#39;/api/manager/menuitemcustomizations&#39;)
class MenuItemCustomizations(Resource):
    &#34;&#34;&#34;
    Resource for retrieving menuitem-customizations join table information.
    &#34;&#34;&#34;
    @api.expect(GetCustomizationsFromMenuItem_model, validate=True)
    def put(self): #GetCustomizationsFromMenuItem
        &#34;&#34;&#34;
        PUT method for retrieving customization information from a menu item.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
            result = conn.execution_options(stream_results=True).execute(text(&#34;SELECT Ingredients.IngredientID, Ingredients.IngredientName &#34; +
                &#34;FROM menuitems JOIN menuitemcustomizations ON menuitems.MenuID = menuitemcustomizations.MenuID &#34; +
                &#34;JOIN Ingredients ON menuitemcustomizations.CustomizationID = Ingredients.IngredientID &#34; +
                &#34;WHERE menuitems.MenuID = {inputmenuitemid}&#34;.format(inputmenuitemid = menuitemid)))
            menuitemingredientslist = []
            for row in result:
                menuitemingredientslist.append({&#34;ingredientname&#34;:row.ingredientname, &#34;ingredientid&#34;:row.ingredientid})
        return jsonify(menuitemingredientslist)
    
    @api.expect(AddCustomizationToMenuItem_model, validate=True)
    def post(self): #AddCustomizationToMenuItem
        &#34;&#34;&#34;
        POST method for creating customization information for a menu item.
        &#34;&#34;&#34;
        menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
        customizationid = request.get_json().get(&#34;customizationid&#34;) 

        add_customization_query = &#34;INSERT INTO menuitemCustomizations (MenuID, CustomizationID) values ({inputmenuitemid},{inputcustomizationid})&#34;.format(inputmenuitemid = menuitemid, inputcustomizationid = customizationid)
                   
        with db.engine.connect() as conn:
            result = conn.execute(text(add_customization_query)) #execution_options(stream_results=True).
            conn.commit()

            select_add_customization_query = &#34;SELECT * FROM menuitemcustomizations WHERE menuid = {inputmenuitemid}&#34;.format(inputmenuitemid = menuitemid)
            resultselect = conn.execution_options(stream_results=True).execute(text(select_add_customization_query))
            menuitemcustomizationslist = []
            for row in resultselect:
                menuitemcustomizationslist.append({&#34;menuid&#34;:row.menuid,&#34;customizationid&#34;:row.customizationid})
        return jsonify(menuitemcustomizationslist)
    
    @api.expect(DeleteCustomizationFromMenuItem_model, validate=True)
    def delete(self): #DeleteCustomizationFromMenuItem
        &#34;&#34;&#34;
        DELETE method for deleting customization information from a menu item.
        &#34;&#34;&#34;
        menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
        customizationid = request.get_json().get(&#34;customizationid&#34;) 

        delete_customization_query = &#34;DELETE FROM menuitemCustomizations WHERE MenuID={inputmenuitemid} AND customizationID={inputcustomizationid}&#34;.format(inputmenuitemid = menuitemid, inputcustomizationid = customizationid)

        with db.engine.connect() as conn:
            conn.connection.cursor().execute(delete_customization_query)
            conn.connection.commit()
            return jsonify({&#34;message&#34;:&#34;successfully deleted order with menuid = {inputmenuitemid} and customizationid = {inputcustomizationid}&#34;.format(inputmenuitemid = menuitemid, inputcustomizationid = customizationid)})

@api.route(&#39;/api/manager/orderhistory&#39;)
class OrderHistory(Resource):
    &#34;&#34;&#34;
    Resource for retrieving order history information.
    &#34;&#34;&#34;
    def get(self):
        &#34;&#34;&#34;
        GET method for retrieving order history information.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            limit_query = &#34;LIMIT 100&#34;
            get_order_query = &#34;SELECT * FROM orders {inputquery}&#34;.format(inputquery=limit_query)
            result = conn.execution_options(stream_results=True).execute(text(get_order_query))
            orderlist = []
            for row in result:
                orderlist.append({&#34;orderid&#34;:row.orderid, &#34;customername&#34;:row.customername, &#34;taxprice&#34;:row.taxprice,&#34;baseprice&#34;:row.baseprice,&#34;orderdatetime&#34;:row.orderdatetime,&#34;employeeid&#34;:row.employeeid})
        return jsonify(orderlist)
    
    @api.expect(UpdateOrder_model, validate=True)
    def put(self): 
        &#34;&#34;&#34;
        PUT method for updating order history information.
        &#34;&#34;&#34;
        orderid = request.get_json().get(&#34;orderid&#34;) 
        customername = request.get_json().get(&#34;customername&#34;)
        baseprice = request.get_json().get(&#34;baseprice&#34;) 
        employeeid = request.get_json().get(&#34;employeeid&#34;) 

        if (orderid == 0):
            return jsonify({&#34;message&#34;: &#34;No orderid entered. No query executed.&#34;})
        elif (customername == &#34;string&#34; and baseprice == 0 and employeeid == 0): 
            return jsonify({&#34;message&#34;: &#34;No inputs entered. No query executed.&#34;})
        
        update_order_query = &#34;UPDATE orders SET &#34;
        if (customername != &#34;string&#34;):
            update_order_query += &#34;CustomerName = &#39;{inputcustomername}&#39;,&#34;.format(inputcustomername=customername)
        if (baseprice &gt; 0):
            taxprice = baseprice*0.0825
            update_order_query += &#34;baseprice = {inputbaseprice}, taxprice = {inputtaxprice},&#34;.format(inputbaseprice=baseprice, inputtaxprice=taxprice)
        if (employeeid &gt; 0):
            update_order_query += &#34;employeeID = {inputemployeeid},&#34;.format(inputemployeeid=employeeid)
        update_order_query = update_order_query[:-1]
        update_order_query += &#34; WHERE orderid = {inputorderid}&#34;.format(inputorderid=orderid)

        with db.engine.connect() as conn:
            result = conn.execute(text(update_order_query)) 
            conn.commit()
        return jsonify({&#34;message&#34;: &#34;Successfully updated order history with orderid = {inputorderid}.&#34;.format(inputorderid=orderid)})
    
    @api.expect(DeleteOrder_model, validate=True)
    def delete(self): 
        &#34;&#34;&#34;
        DELETE method for deleting order history information.
        &#34;&#34;&#34;
        orderid = request.get_json().get(&#34;orderid&#34;) #
        if (orderid &gt;= 0):
            delete_order_query = &#34;DELETE FROM Orders WHERE orderid = {inputorderid}&#34;.format(inputorderid = orderid)
        else: 
            #TODO: check for other ways to get failure
            return jsonify({&#34;message&#34;:&#34;failed to deleted order with orderid = {inputorderid}&#34;.format(inputorderid = orderid)})
        with db.engine.connect() as conn:
            result_cursor = conn.connection.cursor().execute(delete_order_query)
        
            conn.connection.commit()

            try:
                if (result_cursor is None):
                    return jsonify({&#34;message&#34;:&#34;successfully deleted order with orderid = {inputorderid}&#34;.format(inputorderid = orderid)})
            except:
                return jsonify({&#34;message&#34;:&#34;failed to deleted order with orderid = {inputorderid}&#34;.format(inputorderid = orderid)})





@api.route(&#39;/api/manager/orderstatuscompleted&#39;)
class OrderStatusCompleted(Resource):
    &#34;&#34;&#34;
    Defines API routes for updating the status of completed orders managed by managers.
    &#34;&#34;&#34;
    @api.expect(OrderStatus_model, validate=True)
    def put(self): 
        &#34;&#34;&#34;
        PUT method for updating the status of an order to &#39;completed&#39;.
        &#34;&#34;&#34;
        orderid = request.get_json().get(&#34;orderid&#34;) 

        if (orderid == 0):
            return jsonify({&#34;message&#34;: &#34;No orderid entered. No query executed.&#34;})
        
        update_order_query = &#34;UPDATE orders SET orderstat = &#39;completed&#39; where orderid = {inputorderid}&#34;.format(inputorderid=orderid)
        
        with db.engine.connect() as conn:
            conn.execute(text(update_order_query)) 
            conn.commit()
        return jsonify({&#34;message&#34;: &#34;Set order status to COMPLETED for orderid = {inputorderid}.&#34;.format(inputorderid=orderid)})

@api.route(&#39;/api/manager/orderstatusinprogress&#39;)
class OrderStatusInprogress(Resource):
    &#34;&#34;&#34;
    Defines API routes for updating the status of in-progress orders managed by managers.
    &#34;&#34;&#34;
    @api.expect(OrderStatus_model, validate=True)
    def put(self): 
        &#34;&#34;&#34;
        PUT method for updating the status of an order to &#39;inprogress&#39;.
        &#34;&#34;&#34;
        orderid = request.get_json().get(&#34;orderid&#34;) 

        if (orderid == 0):
            return jsonify({&#34;message&#34;: &#34;No orderid entered. No query executed.&#34;})
        
        update_order_query = &#34;UPDATE orders SET orderstat = &#39;inprogress&#39; where orderid = {inputorderid}&#34;.format(inputorderid=orderid)
        
        with db.engine.connect() as conn:
            conn.execute(text(update_order_query)) 
            conn.commit()
        return jsonify({&#34;message&#34;: &#34;Set order status to INPROGRESS for orderid = {inputorderid}.&#34;.format(inputorderid=orderid)})

@api.route(&#39;/api/manager/orderstatusdeleted&#39;)
class OrderStatusDeleted(Resource):
    &#34;&#34;&#34;
    Defines API routes for updating the status of deleted orders managed by managers.
    &#34;&#34;&#34;
    @api.expect(OrderStatus_model, validate=True)
    def put(self): 
        &#34;&#34;&#34;
        PUT method for updating the status of an order to &#39;deleted&#39;.
        &#34;&#34;&#34;
        orderid = request.get_json().get(&#34;orderid&#34;) 

        if (orderid == 0):
            return jsonify({&#34;message&#34;: &#34;No orderid entered. No query executed.&#34;})
        
        update_order_query = &#34;UPDATE orders SET orderstat = &#39;deleted&#39; where orderid = {inputorderid}&#34;.format(inputorderid=orderid)
        
        with db.engine.connect() as conn:
            conn.execute(text(update_order_query)) 
            conn.commit()
        return jsonify({&#34;message&#34;: &#34;Set order status to DELETED for orderid = {inputorderid}.&#34;.format(inputorderid=orderid)})

@api.route(&#39;/api/manager/orderstatuscanceled&#39;)
class OrderStatusCanceled(Resource):
    &#34;&#34;&#34;
    Defines API routes for updating the status of canceled orders managed by managers.
    &#34;&#34;&#34;
    @api.expect(OrderStatus_model, validate=True)
    def put(self): 
        &#34;&#34;&#34;
        PUT method for updating the status of an order to &#39;canceled&#39;.
        &#34;&#34;&#34;
        orderid = request.get_json().get(&#34;orderid&#34;) 

        if (orderid == 0):
            return jsonify({&#34;message&#34;: &#34;No orderid entered. No query executed.&#34;})
        
        update_order_query = &#34;UPDATE orders SET orderstat = &#39;canceled&#39; where orderid = {inputorderid}&#34;.format(inputorderid=orderid)
        
        with db.engine.connect() as conn:
            conn.execute(text(update_order_query)) 
            conn.commit()
        return jsonify({&#34;message&#34;: &#34;Set order status to CANCELED for orderid = {inputorderid}.&#34;.format(inputorderid=orderid)})





@api.route(&#39;/api/manager/restockall&#39;)
class RestockAll(Resource):
    &#34;&#34;&#34;
    Defines API routes for restocking all ingredients below the recommended amount.
    &#34;&#34;&#34;
    def get(self): #get all that needs to be restocked
        &#34;&#34;&#34;
        GET method for retrieving all ingredients that need to be restocked.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            get_stmt = &#34;select * from ingredients where count &lt; recommendedamount&#34;
            result = conn.execution_options(stream_results=True).execute(text(get_stmt))
            # ingrdientlist = []
            restocklist = []
            for row in result:
                # print(str(row))
                casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
                stockincrease = casestobuy*row.caseamount
                restocklist.append({&#34;message&#34;:&#34;Need &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory not affected. No restock occurred.&#34;})
            conn.connection.commit()
            if (len(restocklist) == 0):
                return jsonify({&#34;message&#34;: &#34;No inventory is below recommended amount.&#34;})
                # ingrdientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount, &#34;caseamount&#34;:row.caseamount})
        # return jsonify(ingrdientlist)
        return jsonify(restocklist)
    
    # @api.expect(RestockAll_model, validate=True)
    def put(self): #&#34;update&#34; restock all
        &#34;&#34;&#34;
        PUT method for updating all ingredients that need to be restocked.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            get_stmt = &#34;select * from ingredients where count &lt; recommendedamount&#34;
            result = conn.execution_options(stream_results=True).execute(text(get_stmt))
            # ingrdientlist = []
            restocklist = []
            upIng = &#39;&#39;
            logIng = &#39;&#39;
            for row in result:
                # print(str(row))
                casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
                stockincrease = casestobuy*row.caseamount
                logMessage = &#39;RESTOCK ALL: BOUGHT {x} CASES FOR INGREDIENTID = {y}&#39;.format(x=casestobuy,y=row.ingredientid)
                upIng += &#34;UPDATE Ingredients SET Count = Count + &#34;+ str(stockincrease) + &#34; WHERE IngredientID = &#34; + str(row.ingredientid) + &#34;; &#34;
                logIng += &#34;INSERT INTO InventoryLog (IngredientID, AmountChanged, LogMessage, LogDateTime) VALUES (&#34;+ str(row.ingredientid)+&#34;, &#34;+str(stockincrease)+&#34;, &#39;&#34;+logMessage+&#34;&#39;, NOW()); &#34;
                # restocklist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;casesbought&#34;:casestobuy,&#34;stockincrease&#34;:stockincrease,&#34;message&#34;:&#34;Inventory changed. Restock successfull.&#34;})
                restocklist.append({&#34;message&#34;:&#34;Ordered &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory changed. Restock successfull.&#34;})
            if (upIng == &#34;&#34; or logIng == &#34;&#34;):
                return jsonify({&#34;message&#34;: &#34;No inventory is below recommended amount. No query executed.&#34;})
            conn.connection.cursor().execute(upIng)
            conn.connection.cursor().execute(logIng)
            conn.connection.commit()
                # ingrdientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount, &#34;caseamount&#34;:row.caseamount})
        # return jsonify(ingrdientlist)
        return jsonify(restocklist)

@api.route(&#39;/api/manager/restocksome&#39;)
class RestockSome(Resource):
    &#34;&#34;&#34;
    Defines API routes for restocking specified ingredients below the recommended amount.
    &#34;&#34;&#34;
    @api.expect(RestockSome_model, validate=True)
    def post(self): #get restock some
        &#34;&#34;&#34;
        POST method for retrieving ingredients that need to be restocked from a specified list.
        &#34;&#34;&#34;
        ingr_list = request.get_json().get(&#34;ingredientids&#34;, [])
        allingredients = &#34;&#34;
        for id in ingr_list:
            allingredients += &#34;ingredientid = &#34; + str(id) + &#34; or &#34;
        allingredients = allingredients[:-3]
        allingredients += &#34;)&#34;
        # ingredientid = request.get_json().get(&#34;ingredientid&#34;) 
        with db.engine.connect() as conn:
            get_stmt = &#34;select * from ingredients where count &lt; recommendedamount and ({x}&#34;.format(x=allingredients)
            result = conn.execution_options(stream_results=True).execute(text(get_stmt))
            restocklist = []
            for row in result:
                casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
                stockincrease = casestobuy*row.caseamount
                # restocklist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;casesbought&#34;:casestobuy,&#34;stockincrease&#34;:stockincrease,&#34;message&#34;:&#34;Inventory not affected. No restock occurred.&#34;})
                restocklist.append({&#34;message&#34;:&#34;Need &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory not affected. No restock occurred.&#34;})
            if (len(restocklist) == 0):
                return jsonify({&#34;message&#34;: &#34;No inventory for any ingredients provided is below recommended amount. No query executed.&#34;})
                # ingrdientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount, &#34;caseamount&#34;:row.caseamount})
        # return jsonify(ingrdientlist)
        return jsonify(restocklist)
    
    @api.expect(RestockSome_model, validate=True)
    def put(self): #&#34;update&#34; restock some
        &#34;&#34;&#34;
        PUT method for updating ingredients that need to be restocked from a specified list.
        &#34;&#34;&#34;
        ingr_list = request.get_json().get(&#34;ingredientids&#34;, [])
        allingredients = &#34;&#34;
        for id in ingr_list:
            allingredients += &#34;ingredientid = &#34; + str(id) + &#34; or &#34;
        allingredients = allingredients[:-3]
        allingredients += &#34;)&#34;
        # ingredientid = request.get_json().get(&#34;ingredientid&#34;) 
        with db.engine.connect() as conn:
            get_stmt = &#34;select * from ingredients where count &lt; recommendedamount and ({x}&#34;.format(x=allingredients)
            result = conn.execution_options(stream_results=True).execute(text(get_stmt))
            # ingrdientlist = []
            upIng = &#39;&#39;
            logIng = &#39;&#39;
            restocklist = []
            for row in result:
                casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
                stockincrease = casestobuy*row.caseamount
                # restocklist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;casesbought&#34;:casestobuy,&#34;stockincrease&#34;:stockincrease,&#34;message&#34;:&#34;Inventory changed. Restock successfull.&#34;})
                restocklist.append({&#34;message&#34;:&#34;Ordered &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory changed. Restock successfull.&#34;})
                logMessage = &#39;RESTOCK SOME: BOUGHT {x} CASES OF {y}&#39;.format(x=casestobuy,y=row.ingredientname)
                upIng += &#34;UPDATE Ingredients SET Count = Count + &#34;+ str(stockincrease) + &#34; WHERE IngredientID = &#34; + str(row.ingredientid) + &#34;; &#34;
                logIng += &#34;INSERT INTO InventoryLog (IngredientID, AmountChanged, LogMessage, LogDateTime) VALUES (&#34;+ str(row.ingredientid)+&#34;, &#34;+str(+stockincrease)+&#34;, &#39;&#34;+logMessage+&#34;&#39;, NOW()); &#34;
            
            if (len(restocklist) == 0):
                return jsonify({&#34;message&#34;: &#34;No inventory for any ingredients provided is below recommended amount. No query executed.&#34;})
            conn.connection.cursor().execute(upIng)
            conn.connection.cursor().execute(logIng)
            conn.connection.commit()
                # ingrdientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount, &#34;caseamount&#34;:row.caseamount})
        # return jsonify(ingrdientlist)
        return jsonify(restocklist)

@api.route(&#39;/api/manager/restockbylocation&#39;)
class RestockByLocation(Resource):
    &#34;&#34;&#34;
    Defines API routes for restocking ingredients below the recommended amount in a specified location.
    &#34;&#34;&#34;
    @api.expect(RestockByLocation_model, validate=True)
    def post(self): #get restock by location
        &#34;&#34;&#34;
        POST method for retrieving ingredients that need to be restocked from a specified location.
        &#34;&#34;&#34;
        location = request.get_json().get(&#34;location&#34;)
        # print(&#34;location: &#34;+str(location))
        if ((location != &#39;fridge&#39;) and (location != &#39;freezer&#39;) and (location != &#39;pantry&#39;)):
            return jsonify({&#34;message&#34;: &#34;Incorrect or no location entered. No query executed.&#34;})
        with db.engine.connect() as conn:
            get_stmt = &#34;select * from ingredients where count &lt; recommendedamount and location = &#39;{x}&#39;&#34;.format(x=location)
            result = conn.execution_options(stream_results=True).execute(text(get_stmt))
            restocklist = []
            for row in result:
                casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
                stockincrease = casestobuy*row.caseamount
                # restocklist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;casesbought&#34;:casestobuy,&#34;stockincrease&#34;:stockincrease,&#34;message&#34;:&#34;Inventory not affected. No restock occurred.&#34;})
                restocklist.append({&#34;message&#34;:&#34;Need &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory not affected. No restock occurred.&#34;})
            if (len(restocklist) == 0):
                return jsonify({&#34;message&#34;: &#34;No inventory in the location {x} is below recommended amount. No query executed.&#34;.format(x=location)})
        return jsonify(restocklist)

    @api.expect(RestockByLocation_model, validate=True)
    def put(self): #&#34;update&#34; restock by location
        &#34;&#34;&#34;
        PUT method for updating ingredients that need to be restocked from a specified location.
        &#34;&#34;&#34;
        location = request.get_json().get(&#34;location&#34;)
        # print(&#34;location: &#34;+str(location))
        if ((location != &#39;fridge&#39;) and (location != &#39;freezer&#39;) and (location != &#39;pantry&#39;)):
            return jsonify({&#34;message&#34;: &#34;Incorrect or no location entered. No query executed.&#34;})
        with db.engine.connect() as conn:
            get_stmt = &#34;select * from ingredients where count &lt; recommendedamount and location = &#39;{x}&#39;&#34;.format(x=location)
            result = conn.execution_options(stream_results=True).execute(text(get_stmt))
            # ingrdientlist = []
            upIng = &#39;&#39;
            logIng = &#39;&#39;
            restocklist = []
            for row in result:
                casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
                stockincrease = casestobuy*row.caseamount
                # restocklist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;casesbought&#34;:casestobuy,&#34;stockincrease&#34;:stockincrease,&#34;message&#34;:&#34;Inventory changed. Restock successfull.&#34;})
                restocklist.append({&#34;message&#34;:&#34;Ordered &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory changed. Restock successfull.&#34;})
                logMessage = &#34;RESTOCK FOR {z}: BOUGHT {x} CASES OF {y}&#34;.format(z=location,x=casestobuy,y=row.ingredientname)
                upIng += &#34;UPDATE Ingredients SET Count = Count + &#34;+ str(stockincrease) + &#34; WHERE IngredientID = &#34; + str(row.ingredientid) + &#34;; &#34;
                logIng += &#34;INSERT INTO InventoryLog (IngredientID, AmountChanged, LogMessage, LogDateTime) VALUES (&#34;+ str(row.ingredientid)+&#34;, &#34;+str(+stockincrease)+&#34;, &#39;&#34;+logMessage+&#34;&#39;, NOW()); &#34;
            if (len(restocklist) == 0):
                return jsonify({&#34;message&#34;: &#34;No inventory in the location {x} is below recommended amount. No query executed.&#34;.format(x=location)})
            conn.connection.cursor().execute(upIng)
            conn.connection.cursor().execute(logIng)
            conn.connection.commit()
                # ingrdientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount, &#34;caseamount&#34;:row.caseamount})
        # return jsonify(ingrdientlist)
        return jsonify(restocklist)








&#39;&#39;&#39;Manager Reports&#39;&#39;&#39;
@api.route(&#39;/api/manager/reports/generateproductusage&#39;)
class GenerateProductUsage(Resource):
    &#34;&#34;&#34;
    Defines API routes for generating a product usage report (ingredients&#39; change in inventory amounts over a period of time).
    &#34;&#34;&#34;
    @api.expect(GenerateProductUsage_model, validate=True)
    def post(self): 
        &#34;&#34;&#34;
        POST method for retrieving ingredients&#39; change in inventory amounts over a period of time.
        &#34;&#34;&#34;
        startdate = request.get_json().get(&#34;startdate&#34;) 
        startdate_str = text(startdate)
        enddate = request.get_json().get(&#34;enddate&#34;) 
        enddate_str = text(enddate)
        prod_usage_query = &#34;SELECT IL.IngredientID, I.IngredientName, SUM(IL.AmountChanged) AS TotalAmountChanged FROM InventoryLog IL JOIN Ingredients I ON IL.IngredientID = I.IngredientID WHERE IL.AmountChanged &lt; 0 AND DATE(IL.LogDateTime) BETWEEN CAST(&#39;{inputstart}&#39; AS DATE) AND CAST(&#39;{inputend}&#39; AS DATE) GROUP BY IL.IngredientID, I.IngredientName&#34;.format(inputstart = startdate_str, inputend = enddate_str)
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(prod_usage_query))
            ingredientslist = []
            for row in result:
                ingredientslist.append({&#34;ingredientid&#34;:row.ingredientid,&#34;ingredientname&#34;:row.ingredientname, &#34;totalamountchanged&#34;:row.totalamountchanged})
                #TODO: front end report will only need to show Ingredient Name and Total Amount Changed!
        return jsonify(ingredientslist)
    
@api.route(&#39;/api/manager/reports/generatesalesreport&#39;)
class GenerateSalesReport(Resource):
    &#34;&#34;&#34;
    Defines API routes for generating a sales report (menu items&#39; change in sale over a period of time).
    &#34;&#34;&#34;
    @api.expect(GenerateSalesReport_model, validate=True)
    def post(self): 
        &#34;&#34;&#34;
        POST method for retrieving menu items&#39; change in sale over a period of time.
        &#34;&#34;&#34;
        startdate = request.get_json().get(&#34;startdate&#34;) 
        startdate_str = text(startdate)
        enddate = request.get_json().get(&#34;enddate&#34;)
        enddate_str = text(enddate)
        sales_query = &#34;SELECT menuitems.MenuID, menuitems.ItemName, SUM(menuitems.Price) AS TotalSales, COUNT(*) AS OrderCount FROM orders JOIN ordermenuitems ON orders.OrderID = ordermenuitems.OrderID JOIN menuitems ON ordermenuitems.MenuID = menuitems.MenuID WHERE orders.OrderDateTime BETWEEN TO_TIMESTAMP(&#39;{inputstart}&#39;, &#39;YYYY-MM-DD&#39;) AND TO_TIMESTAMP(&#39;{inputend}&#39;, &#39;YYYY-MM-DD&#39;) GROUP BY menuitems.MenuID, menuitems.ItemName ORDER BY TotalSales DESC&#34;.format(inputstart = startdate_str, inputend = enddate_str)
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(sales_query))
            menuitemlist = []
            for row in result:
                menuitemlist.append({&#34;menuid&#34;:row.menuid, &#34;itemname&#34;:row.itemname, &#34;totalsales&#34;:row.totalsales, &#34;ordercount&#34;:row.ordercount})
        return jsonify(menuitemlist)

@api.route(&#39;/api/manager/reports/generateexcessreport&#39;)
class GenerateExcessReport(Resource):
    &#34;&#34;&#34;
    Defines API routes for generating an excess report (menu items that have ingredients that have sold less than 10% over a period of time).
    &#34;&#34;&#34;
    @api.expect(GenerateExcessReport_model, validate=True)
    def post(self): 
        &#34;&#34;&#34;
        POST method for retrieving menu items that have ingredients that have sold less than 10% over a period of time.
        &#34;&#34;&#34;
        startdate = request.get_json().get(&#34;startdate&#34;) 
        startdate_str = text(startdate)
        excess_query = &#34;SELECT DISTINCT mi.MenuID, mi.ItemName FROM ingredients i JOIN menuitemingredients mii ON i.ingredientid = mii.ingredientid JOIN menuitems mi ON mii.menuid = mi.menuid LEFT JOIN ( SELECT ingredientid, SUM(amountchanged) AS total_sold FROM InventoryLog WHERE amountchanged &lt; 1 AND logdatetime BETWEEN CAST(&#39;{inputdate}&#39; AS TIMESTAMP) AND NOW() GROUP BY ingredientid ) il ON i.ingredientid = il.ingredientid WHERE (il.total_sold IS NULL OR -1*il.total_sold &lt; 0.1 * i.count)&#34;.format(inputdate = startdate_str)
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(excess_query))
            ingredientslist = []
            for row in result:
                ingredientslist.append({&#34;menuid&#34;:row.menuid, &#34;itemname&#34;:row.itemname})
        return jsonify(ingredientslist)

@api.route(&#39;/api/manager/reports/generaterestockreport&#39;)
class GenerateRestockReport(Resource):
    &#34;&#34;&#34;
    Defines API routes for generating a restock report (ingredients that have less than the their minimum amount).
    &#34;&#34;&#34;
    def get(self): 
        &#34;&#34;&#34;
        GET method for retrieving ingredients that have less than the their minimum amount.
        &#34;&#34;&#34;
        restock_query = &#34;SELECT * FROM ingredients WHERE count &lt; minamount&#34;
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(restock_query))
            ingredientlist = []
            for row in result:
                ingredientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu, &#34;count&#34;:row.count, &#34;minamount&#34;:row.minamount})
                # TODO: front end will only need to show ingredientname, count as Current Amount, and minamount as Minimum Amount!
        return jsonify(ingredientlist)

@api.route(&#39;/api/manager/reports/generateordertrend&#39;)
class GenerateOrderTrend(Resource):
    &#34;&#34;&#34;
    Defines API routes for generating an order trend report (top ten menu items ordered together).
    &#34;&#34;&#34;
    @api.expect(GenerateOrderTrend_model, validate=True)
    def post(self): 
        &#34;&#34;&#34;
        POST method for retrieving the top ten menu items ordered together.
        &#34;&#34;&#34;
        startdate = request.get_json().get(&#34;startdate&#34;) 
        startdate_str = text(startdate)
        enddate = request.get_json().get(&#34;enddate&#34;) 
        enddate_str = text(enddate)
        order_trend_query = &#34;SELECT DISTINCT MID1, MID2, Count (*) AS count FROM (SELECT n1.itemname AS MID1, n2.itemname AS MID2, t1.OrderID FROM OrderMenuItems t1 JOIN OrderMenuItems t2 ON t1.OrderID = t2.OrderID AND t1.menuID &lt;  t2.MenuID JOIN Orders ON Orders.OrderID = t1.OrderID Join MenuItems n1 ON t1.MenuID = n1.MenuID JOIN MenuItems n2 on n2.MenuID = t2.MenuID WHERE Orders.OrderDateTime BETWEEN CAST(&#39;{inputstart}&#39; AS DATE) AND CAST(&#39;{inputend}&#39; AS DATE)) AS doubleJoin  GROUP BY MID1, MID2 ORDER BY count DESC LIMIT 10&#34;.format(inputstart = startdate_str, inputend = enddate_str)
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(order_trend_query))
            menuitemlist = []
            for row in result:
                menuitemlist.append({&#34;menuid1&#34;:row.mid1, &#34;menuid2&#34;:row.mid2, &#34;count&#34;:row.count})
        return jsonify(menuitemlist)
    




def init():
    &#34;&#34;&#34;
    Initialization function.
    &#34;&#34;&#34;
    return </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="revspos.manager_routes.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialization function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init():
    &#34;&#34;&#34;
    Initialization function.
    &#34;&#34;&#34;
    return </code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="revspos.manager_routes.CompleteOrder"><code class="flex name class">
<span>class <span class="ident">CompleteOrder</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Resource for marking an order as completed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/kitchen/completeorder&#39;)
class CompleteOrder(Resource):
    &#34;&#34;&#34;
    Resource for marking an order as completed.
    &#34;&#34;&#34;

    @api.expect(CompleteOrder_model, validate=True)
    def post(self):
        &#34;&#34;&#34;
        POST method for marking an order as completed.
        &#34;&#34;&#34;
        data = request.get_json()
        orderid = data.get(&#34;orderid&#34;)
        with db.engine.connect() as conn:
            conn.connection.cursor().execute(f&#34;UPDATE ORDERS SET ORDERSTAT = &#39;completed&#39; WHERE ORDERID = {orderid};&#34;)
            conn.connection.commit()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.CompleteOrder.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.CompleteOrder.post"><code class="name flex">
<span>def <span class="ident">post</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>POST method for marking an order as completed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(CompleteOrder_model, validate=True)
def post(self):
    &#34;&#34;&#34;
    POST method for marking an order as completed.
    &#34;&#34;&#34;
    data = request.get_json()
    orderid = data.get(&#34;orderid&#34;)
    with db.engine.connect() as conn:
        conn.connection.cursor().execute(f&#34;UPDATE ORDERS SET ORDERSTAT = &#39;completed&#39; WHERE ORDERID = {orderid};&#34;)
        conn.connection.commit()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.Employee"><code class="flex name class">
<span>class <span class="ident">Employee</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Resource for retrieving employee information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/employee&#39;)
class Employee(Resource):
    &#34;&#34;&#34;
    Resource for retrieving employee information.
    &#34;&#34;&#34;

    def get(self):
        &#34;&#34;&#34;
        GET method for retrieving employee information.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(&#34;select * from employee&#34;))
            employeelist = []
            for row in result:
                employeelist.append({&#34;employeeid&#34;:row.employeeid, &#34;employeename&#34;:row.employeename, &#34;ismanager&#34;:row.ismanager, &#34;salary&#34;:row.salary, &#34;password&#34;:row.password})
        return jsonify(employeelist)

    @api.expect(AddEmployee_model, validate=True)
    def post(self):
        &#34;&#34;&#34;
        POST method for adding a new employee.
        &#34;&#34;&#34;
        data = request.get_json()
        name = data.get(&#34;employeeName&#34;)
        email = data.get(&#34;employeeEmail&#34;)
        isManager = data.get(&#34;isManager&#34;)
        salary = data.get(&#34;salary&#34;)
        password = data.get(&#34;password&#34;)
        add_employee_query = text(&#34;INSERT INTO employee ( EmployeeName,employeeEmail, IsManager, Salary, Password)  VALUES (&#39;{inname}&#39;,&#39;{inemail}&#39;, {inismanager}, {insalary},&#39;{inpass}&#39;)&#34;.format(inname = name,inemail=email, inismanager=isManager, insalary=salary,inpass = password))
        
        with db.engine.connect() as conn:
            conn.execute(add_employee_query)
            conn.commit()
        #except Exception as e:
            # print(e)
            #return jsonify({&#34;message&#34;: &#34;Failed to add employee&#34;})
        
        return jsonify({&#34;message&#34;: &#34;Sucessfully added Employee&#34;})
    

    @api.expect(UpdateEmployee_model, validate=True)
    def put(self):
        &#34;&#34;&#34;
        PUT method for updating employee information.
        &#34;&#34;&#34;
        data = request.get_json()
        empid = data.get(&#34;employeeid&#34;)
        name = data.get(&#34;employeeName&#34;)
        email = data.get(&#34;employeeEmail&#34;)
        isManager = data.get(&#34;isManager&#34;)
        salary = data.get(&#34;salary&#34;)
        password = data.get(&#34;password&#34;)

        if(name == None and email == None and isManager == None and salary == None and password == None):
            return jsonify({&#34;message&#34;: &#34;No inputs entered. No query executed.&#34;})

        update_query = &#34;UPDATE employee SET &#34;
        if (name != None):
            update_query += &#34;employeeName = &#39;{inputname}&#39;,&#34;.format(inputname=name)
        if (email != None):
            update_query += &#34;employeeEmail = &#39;{inputemail}&#39;,&#34;.format(inputemail=email)
        if (isManager != None):
            update_query += &#34;ismanager = {inputisman},&#34;.format(inputisman=isManager)
        if (salary != None):
            update_query += &#34;salary = {inputsalary},&#34;.format(inputsalary=salary)
        if (password != None):
            update_query += &#34;password = &#39;{inputpassword}&#39;,&#34;.format(inputpassword=password)

        update_query = update_query[:-1]
        update_query += &#34; WHERE employeeid = {inputemployeeid}&#34;.format(inputemployeeid=empid)

        with db.engine.connect() as conn:
            conn.execute(text(update_query))
            conn.commit()
        return jsonify({&#34;message&#34;: &#34;successful update of employee&#34;})

    @api.expect(DeleteEmployee_model, validate=True)
    def delete(self):
        &#34;&#34;&#34;
        DELETE method for deleting an employee.
        &#34;&#34;&#34;
        employeeid = request.get_json().get(&#34;employeeid&#34;)

        delete_employee_query = &#34;DELETE FROM employee WHERE EmployeeID = {inputempid}&#34;.format(inputempid=employeeid)
        with db.engine.connect() as conn:
            conn.connection.cursor().execute(delete_employee_query)
            conn.connection.commit()
        
        return jsonify({&#34;message&#34;: &#34;Sucessfully deleted employee with employeeid = {inputempid}&#34;.format(inputempid=employeeid)})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.Employee.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.Employee.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>DELETE method for deleting an employee.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(DeleteEmployee_model, validate=True)
def delete(self):
    &#34;&#34;&#34;
    DELETE method for deleting an employee.
    &#34;&#34;&#34;
    employeeid = request.get_json().get(&#34;employeeid&#34;)

    delete_employee_query = &#34;DELETE FROM employee WHERE EmployeeID = {inputempid}&#34;.format(inputempid=employeeid)
    with db.engine.connect() as conn:
        conn.connection.cursor().execute(delete_employee_query)
        conn.connection.commit()
    
    return jsonify({&#34;message&#34;: &#34;Sucessfully deleted employee with employeeid = {inputempid}&#34;.format(inputempid=employeeid)})</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.Employee.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>GET method for retrieving employee information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self):
    &#34;&#34;&#34;
    GET method for retrieving employee information.
    &#34;&#34;&#34;
    with db.engine.connect() as conn:
        result = conn.execution_options(stream_results=True).execute(text(&#34;select * from employee&#34;))
        employeelist = []
        for row in result:
            employeelist.append({&#34;employeeid&#34;:row.employeeid, &#34;employeename&#34;:row.employeename, &#34;ismanager&#34;:row.ismanager, &#34;salary&#34;:row.salary, &#34;password&#34;:row.password})
    return jsonify(employeelist)</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.Employee.post"><code class="name flex">
<span>def <span class="ident">post</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>POST method for adding a new employee.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(AddEmployee_model, validate=True)
def post(self):
    &#34;&#34;&#34;
    POST method for adding a new employee.
    &#34;&#34;&#34;
    data = request.get_json()
    name = data.get(&#34;employeeName&#34;)
    email = data.get(&#34;employeeEmail&#34;)
    isManager = data.get(&#34;isManager&#34;)
    salary = data.get(&#34;salary&#34;)
    password = data.get(&#34;password&#34;)
    add_employee_query = text(&#34;INSERT INTO employee ( EmployeeName,employeeEmail, IsManager, Salary, Password)  VALUES (&#39;{inname}&#39;,&#39;{inemail}&#39;, {inismanager}, {insalary},&#39;{inpass}&#39;)&#34;.format(inname = name,inemail=email, inismanager=isManager, insalary=salary,inpass = password))
    
    with db.engine.connect() as conn:
        conn.execute(add_employee_query)
        conn.commit()
    #except Exception as e:
        # print(e)
        #return jsonify({&#34;message&#34;: &#34;Failed to add employee&#34;})
    
    return jsonify({&#34;message&#34;: &#34;Sucessfully added Employee&#34;})</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.Employee.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>PUT method for updating employee information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(UpdateEmployee_model, validate=True)
def put(self):
    &#34;&#34;&#34;
    PUT method for updating employee information.
    &#34;&#34;&#34;
    data = request.get_json()
    empid = data.get(&#34;employeeid&#34;)
    name = data.get(&#34;employeeName&#34;)
    email = data.get(&#34;employeeEmail&#34;)
    isManager = data.get(&#34;isManager&#34;)
    salary = data.get(&#34;salary&#34;)
    password = data.get(&#34;password&#34;)

    if(name == None and email == None and isManager == None and salary == None and password == None):
        return jsonify({&#34;message&#34;: &#34;No inputs entered. No query executed.&#34;})

    update_query = &#34;UPDATE employee SET &#34;
    if (name != None):
        update_query += &#34;employeeName = &#39;{inputname}&#39;,&#34;.format(inputname=name)
    if (email != None):
        update_query += &#34;employeeEmail = &#39;{inputemail}&#39;,&#34;.format(inputemail=email)
    if (isManager != None):
        update_query += &#34;ismanager = {inputisman},&#34;.format(inputisman=isManager)
    if (salary != None):
        update_query += &#34;salary = {inputsalary},&#34;.format(inputsalary=salary)
    if (password != None):
        update_query += &#34;password = &#39;{inputpassword}&#39;,&#34;.format(inputpassword=password)

    update_query = update_query[:-1]
    update_query += &#34; WHERE employeeid = {inputemployeeid}&#34;.format(inputemployeeid=empid)

    with db.engine.connect() as conn:
        conn.execute(text(update_query))
        conn.commit()
    return jsonify({&#34;message&#34;: &#34;successful update of employee&#34;})</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.GenerateExcessReport"><code class="flex name class">
<span>class <span class="ident">GenerateExcessReport</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines API routes for generating an excess report (menu items that have ingredients that have sold less than 10% over a period of time).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/reports/generateexcessreport&#39;)
class GenerateExcessReport(Resource):
    &#34;&#34;&#34;
    Defines API routes for generating an excess report (menu items that have ingredients that have sold less than 10% over a period of time).
    &#34;&#34;&#34;
    @api.expect(GenerateExcessReport_model, validate=True)
    def post(self): 
        &#34;&#34;&#34;
        POST method for retrieving menu items that have ingredients that have sold less than 10% over a period of time.
        &#34;&#34;&#34;
        startdate = request.get_json().get(&#34;startdate&#34;) 
        startdate_str = text(startdate)
        excess_query = &#34;SELECT DISTINCT mi.MenuID, mi.ItemName FROM ingredients i JOIN menuitemingredients mii ON i.ingredientid = mii.ingredientid JOIN menuitems mi ON mii.menuid = mi.menuid LEFT JOIN ( SELECT ingredientid, SUM(amountchanged) AS total_sold FROM InventoryLog WHERE amountchanged &lt; 1 AND logdatetime BETWEEN CAST(&#39;{inputdate}&#39; AS TIMESTAMP) AND NOW() GROUP BY ingredientid ) il ON i.ingredientid = il.ingredientid WHERE (il.total_sold IS NULL OR -1*il.total_sold &lt; 0.1 * i.count)&#34;.format(inputdate = startdate_str)
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(excess_query))
            ingredientslist = []
            for row in result:
                ingredientslist.append({&#34;menuid&#34;:row.menuid, &#34;itemname&#34;:row.itemname})
        return jsonify(ingredientslist)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.GenerateExcessReport.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.GenerateExcessReport.post"><code class="name flex">
<span>def <span class="ident">post</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>POST method for retrieving menu items that have ingredients that have sold less than 10% over a period of time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(GenerateExcessReport_model, validate=True)
def post(self): 
    &#34;&#34;&#34;
    POST method for retrieving menu items that have ingredients that have sold less than 10% over a period of time.
    &#34;&#34;&#34;
    startdate = request.get_json().get(&#34;startdate&#34;) 
    startdate_str = text(startdate)
    excess_query = &#34;SELECT DISTINCT mi.MenuID, mi.ItemName FROM ingredients i JOIN menuitemingredients mii ON i.ingredientid = mii.ingredientid JOIN menuitems mi ON mii.menuid = mi.menuid LEFT JOIN ( SELECT ingredientid, SUM(amountchanged) AS total_sold FROM InventoryLog WHERE amountchanged &lt; 1 AND logdatetime BETWEEN CAST(&#39;{inputdate}&#39; AS TIMESTAMP) AND NOW() GROUP BY ingredientid ) il ON i.ingredientid = il.ingredientid WHERE (il.total_sold IS NULL OR -1*il.total_sold &lt; 0.1 * i.count)&#34;.format(inputdate = startdate_str)
    with db.engine.connect() as conn:
        result = conn.execution_options(stream_results=True).execute(text(excess_query))
        ingredientslist = []
        for row in result:
            ingredientslist.append({&#34;menuid&#34;:row.menuid, &#34;itemname&#34;:row.itemname})
    return jsonify(ingredientslist)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.GenerateOrderTrend"><code class="flex name class">
<span>class <span class="ident">GenerateOrderTrend</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines API routes for generating an order trend report (top ten menu items ordered together).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/reports/generateordertrend&#39;)
class GenerateOrderTrend(Resource):
    &#34;&#34;&#34;
    Defines API routes for generating an order trend report (top ten menu items ordered together).
    &#34;&#34;&#34;
    @api.expect(GenerateOrderTrend_model, validate=True)
    def post(self): 
        &#34;&#34;&#34;
        POST method for retrieving the top ten menu items ordered together.
        &#34;&#34;&#34;
        startdate = request.get_json().get(&#34;startdate&#34;) 
        startdate_str = text(startdate)
        enddate = request.get_json().get(&#34;enddate&#34;) 
        enddate_str = text(enddate)
        order_trend_query = &#34;SELECT DISTINCT MID1, MID2, Count (*) AS count FROM (SELECT n1.itemname AS MID1, n2.itemname AS MID2, t1.OrderID FROM OrderMenuItems t1 JOIN OrderMenuItems t2 ON t1.OrderID = t2.OrderID AND t1.menuID &lt;  t2.MenuID JOIN Orders ON Orders.OrderID = t1.OrderID Join MenuItems n1 ON t1.MenuID = n1.MenuID JOIN MenuItems n2 on n2.MenuID = t2.MenuID WHERE Orders.OrderDateTime BETWEEN CAST(&#39;{inputstart}&#39; AS DATE) AND CAST(&#39;{inputend}&#39; AS DATE)) AS doubleJoin  GROUP BY MID1, MID2 ORDER BY count DESC LIMIT 10&#34;.format(inputstart = startdate_str, inputend = enddate_str)
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(order_trend_query))
            menuitemlist = []
            for row in result:
                menuitemlist.append({&#34;menuid1&#34;:row.mid1, &#34;menuid2&#34;:row.mid2, &#34;count&#34;:row.count})
        return jsonify(menuitemlist)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.GenerateOrderTrend.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.GenerateOrderTrend.post"><code class="name flex">
<span>def <span class="ident">post</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>POST method for retrieving the top ten menu items ordered together.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(GenerateOrderTrend_model, validate=True)
def post(self): 
    &#34;&#34;&#34;
    POST method for retrieving the top ten menu items ordered together.
    &#34;&#34;&#34;
    startdate = request.get_json().get(&#34;startdate&#34;) 
    startdate_str = text(startdate)
    enddate = request.get_json().get(&#34;enddate&#34;) 
    enddate_str = text(enddate)
    order_trend_query = &#34;SELECT DISTINCT MID1, MID2, Count (*) AS count FROM (SELECT n1.itemname AS MID1, n2.itemname AS MID2, t1.OrderID FROM OrderMenuItems t1 JOIN OrderMenuItems t2 ON t1.OrderID = t2.OrderID AND t1.menuID &lt;  t2.MenuID JOIN Orders ON Orders.OrderID = t1.OrderID Join MenuItems n1 ON t1.MenuID = n1.MenuID JOIN MenuItems n2 on n2.MenuID = t2.MenuID WHERE Orders.OrderDateTime BETWEEN CAST(&#39;{inputstart}&#39; AS DATE) AND CAST(&#39;{inputend}&#39; AS DATE)) AS doubleJoin  GROUP BY MID1, MID2 ORDER BY count DESC LIMIT 10&#34;.format(inputstart = startdate_str, inputend = enddate_str)
    with db.engine.connect() as conn:
        result = conn.execution_options(stream_results=True).execute(text(order_trend_query))
        menuitemlist = []
        for row in result:
            menuitemlist.append({&#34;menuid1&#34;:row.mid1, &#34;menuid2&#34;:row.mid2, &#34;count&#34;:row.count})
    return jsonify(menuitemlist)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.GenerateProductUsage"><code class="flex name class">
<span>class <span class="ident">GenerateProductUsage</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines API routes for generating a product usage report (ingredients' change in inventory amounts over a period of time).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/reports/generateproductusage&#39;)
class GenerateProductUsage(Resource):
    &#34;&#34;&#34;
    Defines API routes for generating a product usage report (ingredients&#39; change in inventory amounts over a period of time).
    &#34;&#34;&#34;
    @api.expect(GenerateProductUsage_model, validate=True)
    def post(self): 
        &#34;&#34;&#34;
        POST method for retrieving ingredients&#39; change in inventory amounts over a period of time.
        &#34;&#34;&#34;
        startdate = request.get_json().get(&#34;startdate&#34;) 
        startdate_str = text(startdate)
        enddate = request.get_json().get(&#34;enddate&#34;) 
        enddate_str = text(enddate)
        prod_usage_query = &#34;SELECT IL.IngredientID, I.IngredientName, SUM(IL.AmountChanged) AS TotalAmountChanged FROM InventoryLog IL JOIN Ingredients I ON IL.IngredientID = I.IngredientID WHERE IL.AmountChanged &lt; 0 AND DATE(IL.LogDateTime) BETWEEN CAST(&#39;{inputstart}&#39; AS DATE) AND CAST(&#39;{inputend}&#39; AS DATE) GROUP BY IL.IngredientID, I.IngredientName&#34;.format(inputstart = startdate_str, inputend = enddate_str)
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(prod_usage_query))
            ingredientslist = []
            for row in result:
                ingredientslist.append({&#34;ingredientid&#34;:row.ingredientid,&#34;ingredientname&#34;:row.ingredientname, &#34;totalamountchanged&#34;:row.totalamountchanged})
                #TODO: front end report will only need to show Ingredient Name and Total Amount Changed!
        return jsonify(ingredientslist)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.GenerateProductUsage.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.GenerateProductUsage.post"><code class="name flex">
<span>def <span class="ident">post</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>POST method for retrieving ingredients' change in inventory amounts over a period of time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(GenerateProductUsage_model, validate=True)
def post(self): 
    &#34;&#34;&#34;
    POST method for retrieving ingredients&#39; change in inventory amounts over a period of time.
    &#34;&#34;&#34;
    startdate = request.get_json().get(&#34;startdate&#34;) 
    startdate_str = text(startdate)
    enddate = request.get_json().get(&#34;enddate&#34;) 
    enddate_str = text(enddate)
    prod_usage_query = &#34;SELECT IL.IngredientID, I.IngredientName, SUM(IL.AmountChanged) AS TotalAmountChanged FROM InventoryLog IL JOIN Ingredients I ON IL.IngredientID = I.IngredientID WHERE IL.AmountChanged &lt; 0 AND DATE(IL.LogDateTime) BETWEEN CAST(&#39;{inputstart}&#39; AS DATE) AND CAST(&#39;{inputend}&#39; AS DATE) GROUP BY IL.IngredientID, I.IngredientName&#34;.format(inputstart = startdate_str, inputend = enddate_str)
    with db.engine.connect() as conn:
        result = conn.execution_options(stream_results=True).execute(text(prod_usage_query))
        ingredientslist = []
        for row in result:
            ingredientslist.append({&#34;ingredientid&#34;:row.ingredientid,&#34;ingredientname&#34;:row.ingredientname, &#34;totalamountchanged&#34;:row.totalamountchanged})
            #TODO: front end report will only need to show Ingredient Name and Total Amount Changed!
    return jsonify(ingredientslist)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.GenerateRestockReport"><code class="flex name class">
<span>class <span class="ident">GenerateRestockReport</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines API routes for generating a restock report (ingredients that have less than the their minimum amount).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/reports/generaterestockreport&#39;)
class GenerateRestockReport(Resource):
    &#34;&#34;&#34;
    Defines API routes for generating a restock report (ingredients that have less than the their minimum amount).
    &#34;&#34;&#34;
    def get(self): 
        &#34;&#34;&#34;
        GET method for retrieving ingredients that have less than the their minimum amount.
        &#34;&#34;&#34;
        restock_query = &#34;SELECT * FROM ingredients WHERE count &lt; minamount&#34;
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(restock_query))
            ingredientlist = []
            for row in result:
                ingredientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu, &#34;count&#34;:row.count, &#34;minamount&#34;:row.minamount})
                # TODO: front end will only need to show ingredientname, count as Current Amount, and minamount as Minimum Amount!
        return jsonify(ingredientlist)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.GenerateRestockReport.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.GenerateRestockReport.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>GET method for retrieving ingredients that have less than the their minimum amount.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self): 
    &#34;&#34;&#34;
    GET method for retrieving ingredients that have less than the their minimum amount.
    &#34;&#34;&#34;
    restock_query = &#34;SELECT * FROM ingredients WHERE count &lt; minamount&#34;
    with db.engine.connect() as conn:
        result = conn.execution_options(stream_results=True).execute(text(restock_query))
        ingredientlist = []
        for row in result:
            ingredientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu, &#34;count&#34;:row.count, &#34;minamount&#34;:row.minamount})
            # TODO: front end will only need to show ingredientname, count as Current Amount, and minamount as Minimum Amount!
    return jsonify(ingredientlist)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.GenerateSalesReport"><code class="flex name class">
<span>class <span class="ident">GenerateSalesReport</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines API routes for generating a sales report (menu items' change in sale over a period of time).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/reports/generatesalesreport&#39;)
class GenerateSalesReport(Resource):
    &#34;&#34;&#34;
    Defines API routes for generating a sales report (menu items&#39; change in sale over a period of time).
    &#34;&#34;&#34;
    @api.expect(GenerateSalesReport_model, validate=True)
    def post(self): 
        &#34;&#34;&#34;
        POST method for retrieving menu items&#39; change in sale over a period of time.
        &#34;&#34;&#34;
        startdate = request.get_json().get(&#34;startdate&#34;) 
        startdate_str = text(startdate)
        enddate = request.get_json().get(&#34;enddate&#34;)
        enddate_str = text(enddate)
        sales_query = &#34;SELECT menuitems.MenuID, menuitems.ItemName, SUM(menuitems.Price) AS TotalSales, COUNT(*) AS OrderCount FROM orders JOIN ordermenuitems ON orders.OrderID = ordermenuitems.OrderID JOIN menuitems ON ordermenuitems.MenuID = menuitems.MenuID WHERE orders.OrderDateTime BETWEEN TO_TIMESTAMP(&#39;{inputstart}&#39;, &#39;YYYY-MM-DD&#39;) AND TO_TIMESTAMP(&#39;{inputend}&#39;, &#39;YYYY-MM-DD&#39;) GROUP BY menuitems.MenuID, menuitems.ItemName ORDER BY TotalSales DESC&#34;.format(inputstart = startdate_str, inputend = enddate_str)
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(sales_query))
            menuitemlist = []
            for row in result:
                menuitemlist.append({&#34;menuid&#34;:row.menuid, &#34;itemname&#34;:row.itemname, &#34;totalsales&#34;:row.totalsales, &#34;ordercount&#34;:row.ordercount})
        return jsonify(menuitemlist)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.GenerateSalesReport.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.GenerateSalesReport.post"><code class="name flex">
<span>def <span class="ident">post</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>POST method for retrieving menu items' change in sale over a period of time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(GenerateSalesReport_model, validate=True)
def post(self): 
    &#34;&#34;&#34;
    POST method for retrieving menu items&#39; change in sale over a period of time.
    &#34;&#34;&#34;
    startdate = request.get_json().get(&#34;startdate&#34;) 
    startdate_str = text(startdate)
    enddate = request.get_json().get(&#34;enddate&#34;)
    enddate_str = text(enddate)
    sales_query = &#34;SELECT menuitems.MenuID, menuitems.ItemName, SUM(menuitems.Price) AS TotalSales, COUNT(*) AS OrderCount FROM orders JOIN ordermenuitems ON orders.OrderID = ordermenuitems.OrderID JOIN menuitems ON ordermenuitems.MenuID = menuitems.MenuID WHERE orders.OrderDateTime BETWEEN TO_TIMESTAMP(&#39;{inputstart}&#39;, &#39;YYYY-MM-DD&#39;) AND TO_TIMESTAMP(&#39;{inputend}&#39;, &#39;YYYY-MM-DD&#39;) GROUP BY menuitems.MenuID, menuitems.ItemName ORDER BY TotalSales DESC&#34;.format(inputstart = startdate_str, inputend = enddate_str)
    with db.engine.connect() as conn:
        result = conn.execution_options(stream_results=True).execute(text(sales_query))
        menuitemlist = []
        for row in result:
            menuitemlist.append({&#34;menuid&#34;:row.menuid, &#34;itemname&#34;:row.itemname, &#34;totalsales&#34;:row.totalsales, &#34;ordercount&#34;:row.ordercount})
    return jsonify(menuitemlist)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.GetInProgressOrders"><code class="flex name class">
<span>class <span class="ident">GetInProgressOrders</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Resource for retrieving in-progress orders.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/kitchen/getinprogressorders&#39;)
class GetInProgressOrders(Resource):
    &#34;&#34;&#34;
    Resource for retrieving in-progress orders.
    &#34;&#34;&#34;

    def get(self):
        &#34;&#34;&#34;
        GET method for retrieving in-progress orders.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(&#34;SELECT * FROM ORDERS WHERE ORDERSTAT = &#39;inprogress&#39; ORDER BY ORDERID;&#34;))
            orderlist = []
            for row in result:
                order = {}
                order[&#39;orderid&#39;] = row.orderid
                order[&#39;customername&#39;] = row.customername
                orderlist.append(order)
                menuitems = []
                menuresult = conn.execution_options(stream_results=True).execute(text(f&#34;SELECT menuitems.itemname, customizationID FROM orders JOIN ordermenuitems ON ordermenuitems.orderID = orders.orderID JOIN menuitems ON ordermenuitems.menuID = menuitems.menuID where orders.orderID = {row.orderid};&#34;))
                for row2 in menuresult:
                    menuitem = {}
                    menuitem[&#39;menuitemname&#39;] = row2.itemname   
                    if(row2.customizationid != None):
                        custresult = conn.execution_options(stream_results=True).execute(text(f&#34;SELECT customizationID,ingredients.ingredientname AS WantedCustimzation FROM ordermenuitems JOIN customizationordermenu ON ordermenuitems.customizationID = customizationordermenu.customizationordermenuID JOIN ingredients ON customizationordermenu.ingredientID = ingredients.ingredientID JOIN menuitems ON ordermenuitems.menuID = menuitems.menuID WHERE customizationid = {row2.customizationid};&#34;))
                        custs = []
                        for row3 in custresult:
                            custs.append(row3.wantedcustimzation)
                        menuitem[&#39;customizations&#39;] = custs
                    menuitems.append(menuitem)
                order[&#39;menuitems&#39;] = menuitems
            return jsonify(orderlist)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.GetInProgressOrders.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.GetInProgressOrders.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>GET method for retrieving in-progress orders.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self):
    &#34;&#34;&#34;
    GET method for retrieving in-progress orders.
    &#34;&#34;&#34;
    with db.engine.connect() as conn:
        result = conn.execution_options(stream_results=True).execute(text(&#34;SELECT * FROM ORDERS WHERE ORDERSTAT = &#39;inprogress&#39; ORDER BY ORDERID;&#34;))
        orderlist = []
        for row in result:
            order = {}
            order[&#39;orderid&#39;] = row.orderid
            order[&#39;customername&#39;] = row.customername
            orderlist.append(order)
            menuitems = []
            menuresult = conn.execution_options(stream_results=True).execute(text(f&#34;SELECT menuitems.itemname, customizationID FROM orders JOIN ordermenuitems ON ordermenuitems.orderID = orders.orderID JOIN menuitems ON ordermenuitems.menuID = menuitems.menuID where orders.orderID = {row.orderid};&#34;))
            for row2 in menuresult:
                menuitem = {}
                menuitem[&#39;menuitemname&#39;] = row2.itemname   
                if(row2.customizationid != None):
                    custresult = conn.execution_options(stream_results=True).execute(text(f&#34;SELECT customizationID,ingredients.ingredientname AS WantedCustimzation FROM ordermenuitems JOIN customizationordermenu ON ordermenuitems.customizationID = customizationordermenu.customizationordermenuID JOIN ingredients ON customizationordermenu.ingredientID = ingredients.ingredientID JOIN menuitems ON ordermenuitems.menuID = menuitems.menuID WHERE customizationid = {row2.customizationid};&#34;))
                    custs = []
                    for row3 in custresult:
                        custs.append(row3.wantedcustimzation)
                    menuitem[&#39;customizations&#39;] = custs
                menuitems.append(menuitem)
            order[&#39;menuitems&#39;] = menuitems
        return jsonify(orderlist)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.Ingredients"><code class="flex name class">
<span>class <span class="ident">Ingredients</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Resource for retrieving ingredient information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/ingredients&#39;)
class Ingredients(Resource):
    &#34;&#34;&#34;
    Resource for retrieving ingredient information.
    &#34;&#34;&#34;

    def get(self): #GetIngredients
        &#34;&#34;&#34;
        GET method for retrieving ingredient information.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(&#34;select * from ingredients&#34;))
            menuitemlist = []
            for row in result:
                menuitemlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount,&#34;caseamount&#34;:row.caseamount})
        return jsonify(menuitemlist)
    
    @api.expect(AddIngredient_model, validate=True)
    def post(self): #AddIngredient
        &#34;&#34;&#34;
        POST method for creating menu item information.
        &#34;&#34;&#34;
        data = request.get_json()

        ingredientname = data.get(&#34;ingredientname&#34;)
        count = data.get(&#34;count&#34;)
        ppu = data.get(&#34;ppu&#34;)
        minamount = data.get(&#34;minamount&#34;)
        location = data.get(&#34;location&#34;)
        recommendedamount = data.get(&#34;recommendedamount&#34;)
        caseamount = data.get(&#34;caseamount&#34;)

        
        if (ingredientname == &#34;string&#34; or count == 0 or ppu == 0 or minamount == 0 or location == &#39;string&#39; or recommendedamount == 0 or caseamount == 0):
            return jsonify({&#34;message&#34;:&#34;failed to insert ingredient. Missing fields. All fields are required.&#34;})
        
        insert_query = text(&#34;INSERT INTO Ingredients (Ingredientname, Count, PPU, minamount, location, recommendedamount, caseamount) VALUES (&#39;{inputingredientname}&#39;, {inputcount}, {inputppu}, {inputminamount}, &#39;{inputlocation}&#39;, {inputrecamt}, {inputcaseamt})&#34;.format(inputingredientname=ingredientname,inputcount=count,inputppu=ppu, inputminamount=minamount,inputlocation=location,inputrecamt=recommendedamount,inputcaseamt=caseamount))
        with db.engine.connect() as conn:
            conn.execute(insert_query)
            conn.commit()
        return jsonify({&#34;message&#34;:&#34;Sucessfully inserted the ingredient with ingredientname = {inputingredientname}&#34;.format(inputingredientname=ingredientname)})

    @api.expect(UpdateIngredient_model, validate=True)
    def put(self): #UpdateIngredient
        &#34;&#34;&#34;
        PUT method for updating menu item information.
        &#34;&#34;&#34;
        data = request.get_json()
        ingredientid = data.get(&#34;ingredientid&#34;)
        newname = data.get(&#34;ingredientname&#34;)
        newcount = data.get(&#34;count&#34;)
        newppu = data.get(&#34;ppu&#34;)
        newminamount = data.get(&#34;minamount&#34;)
        newloc = data.get(&#34;location&#34;)
        newrecamt = data.get(&#34;recommendedamount&#34;)
        newcaseamt = data.get(&#34;caseamount&#34;)
        
        if (ingredientid == 0):
            return jsonify({&#34;message&#34;: &#34;No ingredientid entered. No query executed.&#34;})
        elif (newname == &#34;string&#34; and newcount == 0 and newppu == 0 and newminamount == 0 and newloc == &#34;string&#34; and newrecamt == 0 and newcaseamt == 0):
            return jsonify({&#34;message&#34;: &#34;No inputs entered. No query executed.&#34;})

        update_query = &#34;UPDATE ingredients SET &#34;
        if (newname != &#34;string&#34;):
            update_query += &#34;ingredientname = &#39;{inputnewname}&#39;,&#34;.format(inputnewname=newname)
        if (newcount &gt; 0):
            update_query += &#34;count = {inputnewcount},&#34;.format(inputnewcount=newcount)
        if (newppu &gt; 0):
            update_query += &#34;ppu = {inputnewppu},&#34;.format(inputnewppu=newppu)
        if (newminamount &gt; 0):
            update_query += &#34;minamount = {inputnewminamount},&#34;.format(inputnewminamount=newminamount)
        if (newloc != &#34;string&#34;):
            update_query += &#34;location = &#39;{inputloc}&#39;,&#34;.format(inputloc=newloc)
        if (newrecamt &gt; 0):
            update_query += &#34;recommendedamount = {inputrecamt},&#34;.format(inputrecamt=newrecamt)
        if (newcaseamt &gt; 0):
            update_query += &#34;caseamount = {inputcaseamt},&#34;.format(inputcaseamt=newcaseamt)
        
        update_query = update_query[:-1]
        update_query += &#34; WHERE IngredientID = {inputingredientid}&#34;.format(inputingredientid=ingredientid)
        try:
            with db.engine.connect() as conn:
                conn.execute(text(update_query))
                conn.commit()
                return jsonify({&#34;message&#34;: &#34;successful update of ingredient with ingredientid = {inputingredientid}&#34;.format(inputingredientid=ingredientid)})
        except ObjectNotExecutableError:
            return jsonify({&#34;message&#34;:&#34;failed to find ingredient with ingredientid = {inputingredientid}&#34;.format(inputingredientid=ingredientid)})
    
    @api.expect(DeleteIngredient_model, validate=True)
    def delete(self): #DeleteIngredient #TODO: FIX THIS ONE. THERE&#39;S A TON OF EXECUTES AND NO ERROR CHECKING, 
        &#34;&#34;&#34;
        DELETE method for deleting menu item information.
        &#34;&#34;&#34;
        data = request.get_json()
        ingredientid = data.get(&#34;ingredientid&#34;)
        count = data.get(&#34;count&#34;)

        delete_from_join_cmd = &#34;DELETE FROM MenuItemIngredients WHERE IngredientID = {inputingredientid}&#34;.format(inputingredientid=ingredientid)
        with db.engine.connect() as conn:
            conn.connection.cursor().execute(delete_from_join_cmd)
            conn.connection.commit()

        delete_ingredient_cmd = &#34;DELETE FROM Ingredients WHERE IngredientID = {inputingredientid}&#34;.format(inputingredientid=ingredientid)
        with db.engine.connect() as conn:
            conn.connection.cursor().execute(delete_ingredient_cmd)
            conn.connection.commit()

        negate_count = count * -1
        log_message = &#34;INGREDIENT COUNT SET TO 0: DELETED INGREDIENT WITH INGREDIENTID = {inputingredientid}&#34;.format(inputingredientid=ingredientid)

        insert_log_cmd = text(&#34;INSERT INTO InventoryLog (IngredientID, AmountChanged, LogMessage, LogDateTime) VALUES ({inputingredientid}, {inputnegate_count}, &#39;{inputlog_message}&#39;, NOW())&#34;.format(inputingredientid=ingredientid, inputnegate_count=negate_count, inputlog_message=log_message))
        try:         
            with db.engine.connect() as conn:
                conn.execute(insert_log_cmd)
                conn.commit()
            return jsonify({&#34;message&#34;: &#34;successful deletion of ingredient with ingredientid = {inputingredientid}&#34;.format(inputingredientid=ingredientid)})
        except ObjectNotExecutableError as e:
            return jsonify({&#34;message&#34;:&#34;failed to delete ingredient with ingredientid = {inputingredientid}&#34;.format(inputingredientid=ingredientid)})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.Ingredients.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.Ingredients.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>DELETE method for deleting menu item information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(DeleteIngredient_model, validate=True)
def delete(self): #DeleteIngredient #TODO: FIX THIS ONE. THERE&#39;S A TON OF EXECUTES AND NO ERROR CHECKING, 
    &#34;&#34;&#34;
    DELETE method for deleting menu item information.
    &#34;&#34;&#34;
    data = request.get_json()
    ingredientid = data.get(&#34;ingredientid&#34;)
    count = data.get(&#34;count&#34;)

    delete_from_join_cmd = &#34;DELETE FROM MenuItemIngredients WHERE IngredientID = {inputingredientid}&#34;.format(inputingredientid=ingredientid)
    with db.engine.connect() as conn:
        conn.connection.cursor().execute(delete_from_join_cmd)
        conn.connection.commit()

    delete_ingredient_cmd = &#34;DELETE FROM Ingredients WHERE IngredientID = {inputingredientid}&#34;.format(inputingredientid=ingredientid)
    with db.engine.connect() as conn:
        conn.connection.cursor().execute(delete_ingredient_cmd)
        conn.connection.commit()

    negate_count = count * -1
    log_message = &#34;INGREDIENT COUNT SET TO 0: DELETED INGREDIENT WITH INGREDIENTID = {inputingredientid}&#34;.format(inputingredientid=ingredientid)

    insert_log_cmd = text(&#34;INSERT INTO InventoryLog (IngredientID, AmountChanged, LogMessage, LogDateTime) VALUES ({inputingredientid}, {inputnegate_count}, &#39;{inputlog_message}&#39;, NOW())&#34;.format(inputingredientid=ingredientid, inputnegate_count=negate_count, inputlog_message=log_message))
    try:         
        with db.engine.connect() as conn:
            conn.execute(insert_log_cmd)
            conn.commit()
        return jsonify({&#34;message&#34;: &#34;successful deletion of ingredient with ingredientid = {inputingredientid}&#34;.format(inputingredientid=ingredientid)})
    except ObjectNotExecutableError as e:
        return jsonify({&#34;message&#34;:&#34;failed to delete ingredient with ingredientid = {inputingredientid}&#34;.format(inputingredientid=ingredientid)})</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.Ingredients.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>GET method for retrieving ingredient information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self): #GetIngredients
    &#34;&#34;&#34;
    GET method for retrieving ingredient information.
    &#34;&#34;&#34;
    with db.engine.connect() as conn:
        result = conn.execution_options(stream_results=True).execute(text(&#34;select * from ingredients&#34;))
        menuitemlist = []
        for row in result:
            menuitemlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount,&#34;caseamount&#34;:row.caseamount})
    return jsonify(menuitemlist)</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.Ingredients.post"><code class="name flex">
<span>def <span class="ident">post</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>POST method for creating menu item information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(AddIngredient_model, validate=True)
def post(self): #AddIngredient
    &#34;&#34;&#34;
    POST method for creating menu item information.
    &#34;&#34;&#34;
    data = request.get_json()

    ingredientname = data.get(&#34;ingredientname&#34;)
    count = data.get(&#34;count&#34;)
    ppu = data.get(&#34;ppu&#34;)
    minamount = data.get(&#34;minamount&#34;)
    location = data.get(&#34;location&#34;)
    recommendedamount = data.get(&#34;recommendedamount&#34;)
    caseamount = data.get(&#34;caseamount&#34;)

    
    if (ingredientname == &#34;string&#34; or count == 0 or ppu == 0 or minamount == 0 or location == &#39;string&#39; or recommendedamount == 0 or caseamount == 0):
        return jsonify({&#34;message&#34;:&#34;failed to insert ingredient. Missing fields. All fields are required.&#34;})
    
    insert_query = text(&#34;INSERT INTO Ingredients (Ingredientname, Count, PPU, minamount, location, recommendedamount, caseamount) VALUES (&#39;{inputingredientname}&#39;, {inputcount}, {inputppu}, {inputminamount}, &#39;{inputlocation}&#39;, {inputrecamt}, {inputcaseamt})&#34;.format(inputingredientname=ingredientname,inputcount=count,inputppu=ppu, inputminamount=minamount,inputlocation=location,inputrecamt=recommendedamount,inputcaseamt=caseamount))
    with db.engine.connect() as conn:
        conn.execute(insert_query)
        conn.commit()
    return jsonify({&#34;message&#34;:&#34;Sucessfully inserted the ingredient with ingredientname = {inputingredientname}&#34;.format(inputingredientname=ingredientname)})</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.Ingredients.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>PUT method for updating menu item information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(UpdateIngredient_model, validate=True)
def put(self): #UpdateIngredient
    &#34;&#34;&#34;
    PUT method for updating menu item information.
    &#34;&#34;&#34;
    data = request.get_json()
    ingredientid = data.get(&#34;ingredientid&#34;)
    newname = data.get(&#34;ingredientname&#34;)
    newcount = data.get(&#34;count&#34;)
    newppu = data.get(&#34;ppu&#34;)
    newminamount = data.get(&#34;minamount&#34;)
    newloc = data.get(&#34;location&#34;)
    newrecamt = data.get(&#34;recommendedamount&#34;)
    newcaseamt = data.get(&#34;caseamount&#34;)
    
    if (ingredientid == 0):
        return jsonify({&#34;message&#34;: &#34;No ingredientid entered. No query executed.&#34;})
    elif (newname == &#34;string&#34; and newcount == 0 and newppu == 0 and newminamount == 0 and newloc == &#34;string&#34; and newrecamt == 0 and newcaseamt == 0):
        return jsonify({&#34;message&#34;: &#34;No inputs entered. No query executed.&#34;})

    update_query = &#34;UPDATE ingredients SET &#34;
    if (newname != &#34;string&#34;):
        update_query += &#34;ingredientname = &#39;{inputnewname}&#39;,&#34;.format(inputnewname=newname)
    if (newcount &gt; 0):
        update_query += &#34;count = {inputnewcount},&#34;.format(inputnewcount=newcount)
    if (newppu &gt; 0):
        update_query += &#34;ppu = {inputnewppu},&#34;.format(inputnewppu=newppu)
    if (newminamount &gt; 0):
        update_query += &#34;minamount = {inputnewminamount},&#34;.format(inputnewminamount=newminamount)
    if (newloc != &#34;string&#34;):
        update_query += &#34;location = &#39;{inputloc}&#39;,&#34;.format(inputloc=newloc)
    if (newrecamt &gt; 0):
        update_query += &#34;recommendedamount = {inputrecamt},&#34;.format(inputrecamt=newrecamt)
    if (newcaseamt &gt; 0):
        update_query += &#34;caseamount = {inputcaseamt},&#34;.format(inputcaseamt=newcaseamt)
    
    update_query = update_query[:-1]
    update_query += &#34; WHERE IngredientID = {inputingredientid}&#34;.format(inputingredientid=ingredientid)
    try:
        with db.engine.connect() as conn:
            conn.execute(text(update_query))
            conn.commit()
            return jsonify({&#34;message&#34;: &#34;successful update of ingredient with ingredientid = {inputingredientid}&#34;.format(inputingredientid=ingredientid)})
    except ObjectNotExecutableError:
        return jsonify({&#34;message&#34;:&#34;failed to find ingredient with ingredientid = {inputingredientid}&#34;.format(inputingredientid=ingredientid)})</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.MenuItemCustomizations"><code class="flex name class">
<span>class <span class="ident">MenuItemCustomizations</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Resource for retrieving menuitem-customizations join table information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/menuitemcustomizations&#39;)
class MenuItemCustomizations(Resource):
    &#34;&#34;&#34;
    Resource for retrieving menuitem-customizations join table information.
    &#34;&#34;&#34;
    @api.expect(GetCustomizationsFromMenuItem_model, validate=True)
    def put(self): #GetCustomizationsFromMenuItem
        &#34;&#34;&#34;
        PUT method for retrieving customization information from a menu item.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
            result = conn.execution_options(stream_results=True).execute(text(&#34;SELECT Ingredients.IngredientID, Ingredients.IngredientName &#34; +
                &#34;FROM menuitems JOIN menuitemcustomizations ON menuitems.MenuID = menuitemcustomizations.MenuID &#34; +
                &#34;JOIN Ingredients ON menuitemcustomizations.CustomizationID = Ingredients.IngredientID &#34; +
                &#34;WHERE menuitems.MenuID = {inputmenuitemid}&#34;.format(inputmenuitemid = menuitemid)))
            menuitemingredientslist = []
            for row in result:
                menuitemingredientslist.append({&#34;ingredientname&#34;:row.ingredientname, &#34;ingredientid&#34;:row.ingredientid})
        return jsonify(menuitemingredientslist)
    
    @api.expect(AddCustomizationToMenuItem_model, validate=True)
    def post(self): #AddCustomizationToMenuItem
        &#34;&#34;&#34;
        POST method for creating customization information for a menu item.
        &#34;&#34;&#34;
        menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
        customizationid = request.get_json().get(&#34;customizationid&#34;) 

        add_customization_query = &#34;INSERT INTO menuitemCustomizations (MenuID, CustomizationID) values ({inputmenuitemid},{inputcustomizationid})&#34;.format(inputmenuitemid = menuitemid, inputcustomizationid = customizationid)
                   
        with db.engine.connect() as conn:
            result = conn.execute(text(add_customization_query)) #execution_options(stream_results=True).
            conn.commit()

            select_add_customization_query = &#34;SELECT * FROM menuitemcustomizations WHERE menuid = {inputmenuitemid}&#34;.format(inputmenuitemid = menuitemid)
            resultselect = conn.execution_options(stream_results=True).execute(text(select_add_customization_query))
            menuitemcustomizationslist = []
            for row in resultselect:
                menuitemcustomizationslist.append({&#34;menuid&#34;:row.menuid,&#34;customizationid&#34;:row.customizationid})
        return jsonify(menuitemcustomizationslist)
    
    @api.expect(DeleteCustomizationFromMenuItem_model, validate=True)
    def delete(self): #DeleteCustomizationFromMenuItem
        &#34;&#34;&#34;
        DELETE method for deleting customization information from a menu item.
        &#34;&#34;&#34;
        menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
        customizationid = request.get_json().get(&#34;customizationid&#34;) 

        delete_customization_query = &#34;DELETE FROM menuitemCustomizations WHERE MenuID={inputmenuitemid} AND customizationID={inputcustomizationid}&#34;.format(inputmenuitemid = menuitemid, inputcustomizationid = customizationid)

        with db.engine.connect() as conn:
            conn.connection.cursor().execute(delete_customization_query)
            conn.connection.commit()
            return jsonify({&#34;message&#34;:&#34;successfully deleted order with menuid = {inputmenuitemid} and customizationid = {inputcustomizationid}&#34;.format(inputmenuitemid = menuitemid, inputcustomizationid = customizationid)})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.MenuItemCustomizations.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.MenuItemCustomizations.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>DELETE method for deleting customization information from a menu item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(DeleteCustomizationFromMenuItem_model, validate=True)
def delete(self): #DeleteCustomizationFromMenuItem
    &#34;&#34;&#34;
    DELETE method for deleting customization information from a menu item.
    &#34;&#34;&#34;
    menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
    customizationid = request.get_json().get(&#34;customizationid&#34;) 

    delete_customization_query = &#34;DELETE FROM menuitemCustomizations WHERE MenuID={inputmenuitemid} AND customizationID={inputcustomizationid}&#34;.format(inputmenuitemid = menuitemid, inputcustomizationid = customizationid)

    with db.engine.connect() as conn:
        conn.connection.cursor().execute(delete_customization_query)
        conn.connection.commit()
        return jsonify({&#34;message&#34;:&#34;successfully deleted order with menuid = {inputmenuitemid} and customizationid = {inputcustomizationid}&#34;.format(inputmenuitemid = menuitemid, inputcustomizationid = customizationid)})</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.MenuItemCustomizations.post"><code class="name flex">
<span>def <span class="ident">post</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>POST method for creating customization information for a menu item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(AddCustomizationToMenuItem_model, validate=True)
def post(self): #AddCustomizationToMenuItem
    &#34;&#34;&#34;
    POST method for creating customization information for a menu item.
    &#34;&#34;&#34;
    menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
    customizationid = request.get_json().get(&#34;customizationid&#34;) 

    add_customization_query = &#34;INSERT INTO menuitemCustomizations (MenuID, CustomizationID) values ({inputmenuitemid},{inputcustomizationid})&#34;.format(inputmenuitemid = menuitemid, inputcustomizationid = customizationid)
               
    with db.engine.connect() as conn:
        result = conn.execute(text(add_customization_query)) #execution_options(stream_results=True).
        conn.commit()

        select_add_customization_query = &#34;SELECT * FROM menuitemcustomizations WHERE menuid = {inputmenuitemid}&#34;.format(inputmenuitemid = menuitemid)
        resultselect = conn.execution_options(stream_results=True).execute(text(select_add_customization_query))
        menuitemcustomizationslist = []
        for row in resultselect:
            menuitemcustomizationslist.append({&#34;menuid&#34;:row.menuid,&#34;customizationid&#34;:row.customizationid})
    return jsonify(menuitemcustomizationslist)</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.MenuItemCustomizations.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>PUT method for retrieving customization information from a menu item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(GetCustomizationsFromMenuItem_model, validate=True)
def put(self): #GetCustomizationsFromMenuItem
    &#34;&#34;&#34;
    PUT method for retrieving customization information from a menu item.
    &#34;&#34;&#34;
    with db.engine.connect() as conn:
        menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
        result = conn.execution_options(stream_results=True).execute(text(&#34;SELECT Ingredients.IngredientID, Ingredients.IngredientName &#34; +
            &#34;FROM menuitems JOIN menuitemcustomizations ON menuitems.MenuID = menuitemcustomizations.MenuID &#34; +
            &#34;JOIN Ingredients ON menuitemcustomizations.CustomizationID = Ingredients.IngredientID &#34; +
            &#34;WHERE menuitems.MenuID = {inputmenuitemid}&#34;.format(inputmenuitemid = menuitemid)))
        menuitemingredientslist = []
        for row in result:
            menuitemingredientslist.append({&#34;ingredientname&#34;:row.ingredientname, &#34;ingredientid&#34;:row.ingredientid})
    return jsonify(menuitemingredientslist)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.MenuItemIngredients"><code class="flex name class">
<span>class <span class="ident">MenuItemIngredients</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Resource for retrieving menuitem-ingredient join table information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/menuitemingredients&#39;)
class MenuItemIngredients(Resource):
    &#34;&#34;&#34;
    Resource for retrieving menuitem-ingredient join table information.
    &#34;&#34;&#34;
    @api.expect(GetIngredientsFromMenuItem_model, validate=True)
    def put(self): #GetIngredientFromMenuItem
        &#34;&#34;&#34;
        PUT method for retrieving ingredient information from a menu item.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
            result = conn.execution_options(stream_results=True).execute(text(&#34;SELECT Ingredients.IngredientID, Ingredients.IngredientName &#34; +
                &#34;FROM menuitems JOIN menuitemingredients ON menuitems.MenuID = menuitemingredients.MenuID &#34; +
                &#34;JOIN Ingredients ON menuitemingredients.IngredientID = Ingredients.IngredientID &#34; +
                &#34;WHERE menuitems.MenuID = {inputmenuitemid}&#34;.format(inputmenuitemid = menuitemid)))
            menuitemingredientslist = []
            for row in result:
                menuitemingredientslist.append({&#34;ingredientname&#34;:row.ingredientname, &#34;ingredientid&#34;:row.ingredientid})
        return jsonify(menuitemingredientslist)
    
    @api.expect(AddIngredientToMenuItem_model, validate=True)
    def post(self): #AddIngredientToMenuItem
        &#34;&#34;&#34;
        POST method for creating ingredient information for a menu item.
        &#34;&#34;&#34;
        menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
        ingredientid = request.get_json().get(&#34;ingredientid&#34;) 

        add_ingredient_query = &#34;INSERT INTO menuitemIngredients (MenuID, IngredientID) values ({inputmenuitemid},{inputingredientid})&#34;.format(inputmenuitemid = menuitemid, inputingredientid = ingredientid)
                   
        with db.engine.connect() as conn:
            result = conn.execute(text(add_ingredient_query)) #execution_options(stream_results=True).
            conn.commit()

            select_add_ingredient_query = &#34;SELECT * FROM menuitemingredients WHERE menuid = {inputmenuitemid}&#34;.format(inputmenuitemid = menuitemid)
            resultselect = conn.execution_options(stream_results=True).execute(text(select_add_ingredient_query))
            menuitemingredientslist = []
            for row in resultselect:
                menuitemingredientslist.append({&#34;menuid&#34;:row.menuid,&#34;ingredientid&#34;:row.ingredientid})
        return jsonify(menuitemingredientslist)
    
    @api.expect(DeleteIngredientFromMenuItem_model, validate=True)
    def delete(self): 
        &#34;&#34;&#34;
        DELETE method for deleting ingredient information from a menu item.
        &#34;&#34;&#34;
        menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
        ingredientid = request.get_json().get(&#34;ingredientid&#34;) 

        delete_ingredient_query = &#34;DELETE FROM menuitemIngredients WHERE MenuID={inputmenuitemid} AND ingredientID={inputingredientid}&#34;.format(inputmenuitemid = menuitemid, inputingredientid = ingredientid)

        with db.engine.connect() as conn:
            conn.connection.cursor().execute(delete_ingredient_query)
            conn.connection.commit()
            return jsonify({&#34;message&#34;:&#34;successfully deleted order with menuid = {inputmenuitemid} and ingredient = {inputingredientid}&#34;.format(inputmenuitemid = menuitemid, inputingredientid = ingredientid)})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.MenuItemIngredients.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.MenuItemIngredients.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>DELETE method for deleting ingredient information from a menu item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(DeleteIngredientFromMenuItem_model, validate=True)
def delete(self): 
    &#34;&#34;&#34;
    DELETE method for deleting ingredient information from a menu item.
    &#34;&#34;&#34;
    menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
    ingredientid = request.get_json().get(&#34;ingredientid&#34;) 

    delete_ingredient_query = &#34;DELETE FROM menuitemIngredients WHERE MenuID={inputmenuitemid} AND ingredientID={inputingredientid}&#34;.format(inputmenuitemid = menuitemid, inputingredientid = ingredientid)

    with db.engine.connect() as conn:
        conn.connection.cursor().execute(delete_ingredient_query)
        conn.connection.commit()
        return jsonify({&#34;message&#34;:&#34;successfully deleted order with menuid = {inputmenuitemid} and ingredient = {inputingredientid}&#34;.format(inputmenuitemid = menuitemid, inputingredientid = ingredientid)})</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.MenuItemIngredients.post"><code class="name flex">
<span>def <span class="ident">post</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>POST method for creating ingredient information for a menu item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(AddIngredientToMenuItem_model, validate=True)
def post(self): #AddIngredientToMenuItem
    &#34;&#34;&#34;
    POST method for creating ingredient information for a menu item.
    &#34;&#34;&#34;
    menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
    ingredientid = request.get_json().get(&#34;ingredientid&#34;) 

    add_ingredient_query = &#34;INSERT INTO menuitemIngredients (MenuID, IngredientID) values ({inputmenuitemid},{inputingredientid})&#34;.format(inputmenuitemid = menuitemid, inputingredientid = ingredientid)
               
    with db.engine.connect() as conn:
        result = conn.execute(text(add_ingredient_query)) #execution_options(stream_results=True).
        conn.commit()

        select_add_ingredient_query = &#34;SELECT * FROM menuitemingredients WHERE menuid = {inputmenuitemid}&#34;.format(inputmenuitemid = menuitemid)
        resultselect = conn.execution_options(stream_results=True).execute(text(select_add_ingredient_query))
        menuitemingredientslist = []
        for row in resultselect:
            menuitemingredientslist.append({&#34;menuid&#34;:row.menuid,&#34;ingredientid&#34;:row.ingredientid})
    return jsonify(menuitemingredientslist)</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.MenuItemIngredients.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>PUT method for retrieving ingredient information from a menu item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(GetIngredientsFromMenuItem_model, validate=True)
def put(self): #GetIngredientFromMenuItem
    &#34;&#34;&#34;
    PUT method for retrieving ingredient information from a menu item.
    &#34;&#34;&#34;
    with db.engine.connect() as conn:
        menuitemid = request.get_json().get(&#34;menuitemid&#34;) 
        result = conn.execution_options(stream_results=True).execute(text(&#34;SELECT Ingredients.IngredientID, Ingredients.IngredientName &#34; +
            &#34;FROM menuitems JOIN menuitemingredients ON menuitems.MenuID = menuitemingredients.MenuID &#34; +
            &#34;JOIN Ingredients ON menuitemingredients.IngredientID = Ingredients.IngredientID &#34; +
            &#34;WHERE menuitems.MenuID = {inputmenuitemid}&#34;.format(inputmenuitemid = menuitemid)))
        menuitemingredientslist = []
        for row in result:
            menuitemingredientslist.append({&#34;ingredientname&#34;:row.ingredientname, &#34;ingredientid&#34;:row.ingredientid})
    return jsonify(menuitemingredientslist)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.MenuItems"><code class="flex name class">
<span>class <span class="ident">MenuItems</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Resource for retrieving menu item information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/menuitems&#39;)
class MenuItems(Resource):
    &#34;&#34;&#34;
    Resource for retrieving menu item information.
    &#34;&#34;&#34;

    def get(self): #GetMenuItem
        &#34;&#34;&#34;
        GET method for retrieving menu item information.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(text(&#34;select * from menuitems&#34;))
            menuitemlist = []
            for row in result:
                menuitemlist.append({&#34;menuid&#34;:row.menuid, &#34;itemname&#34;:row.itemname, &#34;price&#34;:row.price, &#34;picturepath&#34;:row.picturepath})
        return jsonify(menuitemlist)
    
    @api.expect(AddMenuItem_model, validate=False)
    def post(self): #AddMenuItem
        &#34;&#34;&#34;
        POST method for creating menu item information.
        &#34;&#34;&#34;
        # print(&#34;GOT HERE&#34;)
        data = request.get_json()
        category = data.get(&#34;category&#34;)
        itemname = data.get(&#34;itemname&#34;)
        price = data.get(&#34;price&#34;)
        menuid = 0

        select_query = text(&#34;SELECT MENUID FROM MENUITEMS WHERE MENUID BETWEEN {lowerbound} AND {upperbound} ORDER BY MENUID DESC LIMIT 1;&#34;.format(lowerbound = category,upperbound = int(category) + 100))
        with db.engine.connect() as conn:
            result = conn.execution_options(stream_results=True).execute(select_query)
            for row in result:
                menuid = row.menuid + 1

        add_menu_item_query = text(&#34;INSERT INTO MenuItems (MenuID, ItemName, Price) VALUES ({inputmenuid}, &#39;{inputitemname}&#39;, {inputprice})&#34;.format(inputmenuid=menuid, inputitemname=itemname, inputprice=price))
        try:
            with db.engine.connect() as conn:
                conn.execute(add_menu_item_query)
                conn.commit()
        except Exception as e:
            # print(e)
            return jsonify({&#34;message&#34;: &#34;Failed to add menu item&#34;})
        
        return jsonify({&#34;message&#34;: &#34;Sucessfully added Menu item with menuid = {inputmenuid}&#34;.format(inputmenuid=menuid)})
    
    @api.expect(UpdateMenuItem_model, validate=True)
    def put(self): #UpdateMenuItem
        &#34;&#34;&#34;
        PUT method for updating menu item information.
        &#34;&#34;&#34;
        data = request.get_json()
        menuid = data.get(&#34;menuid&#34;)
        itemname = data.get(&#34;itemname&#34;)
        price = data.get(&#34;price&#34;)

        if (menuid == 0):
            return jsonify({&#34;message&#34;: &#34;No Menu Item ID entered. No query executed.&#34;})
        elif (itemname == &#34;string&#34; and price == 0):
            return jsonify({&#34;message&#34;: &#34;No inputs entered. No query executed.&#34;})
        
        update_query = &#34;UPDATE menuitems SET &#34;
        if (itemname != &#34;string&#34;):
            update_query += &#34;itemname = &#39;{inputnewname}&#39;,&#34;.format(inputnewname=itemname)
        if (price &gt; 0):
            update_query += &#34;price = {inputnewprice},&#34;.format(inputnewprice=price)

        update_query = update_query[:-1]
        update_query += &#34; WHERE menuid = {inputmenuidid}&#34;.format(inputmenuidid=menuid)

        with db.engine.connect() as conn:
            result = conn.execute(text(update_query))
            conn.commit()
        return jsonify({&#34;message&#34;: &#34;successful update of menu item with menuid = {inputmenuid}&#34;.format(inputmenuid=menuid)})

    @api.expect(DeleteMenuItem_model, validate=True)
    def delete(self): #DeleteMenuItem #TODO: need to do a check where the menuid actually exists first before doing queries. Success msg is wrongfully shown when deleting menuid that doesnt exist in the db
        &#34;&#34;&#34;
        DELETE method for deleting menu item information.
        &#34;&#34;&#34;
        menuid = request.get_json().get(&#34;menuid&#34;)

        delete_menuitemingredients_query = &#34;DELETE FROM menuitemIngredients WHERE MenuID = {inputmenuid}&#34;.format(inputmenuid=menuid)
        with db.engine.connect() as conn:
            conn.connection.cursor().execute(delete_menuitemingredients_query)
            conn.connection.commit()
        
        delete_menuitem_query = &#34;DELETE FROM menuitems WHERE MenuID = {inputmenuid}&#34;.format(inputmenuid=menuid)
        with db.engine.connect() as conn:
            conn.connection.cursor().execute(delete_menuitem_query)
            conn.connection.commit()
        
        return jsonify({&#34;message&#34;: &#34;Sucessfully deleted Menu item with menuid = {inputmenuid}&#34;.format(inputmenuid=menuid)})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.MenuItems.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.MenuItems.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>DELETE method for deleting menu item information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(DeleteMenuItem_model, validate=True)
def delete(self): #DeleteMenuItem #TODO: need to do a check where the menuid actually exists first before doing queries. Success msg is wrongfully shown when deleting menuid that doesnt exist in the db
    &#34;&#34;&#34;
    DELETE method for deleting menu item information.
    &#34;&#34;&#34;
    menuid = request.get_json().get(&#34;menuid&#34;)

    delete_menuitemingredients_query = &#34;DELETE FROM menuitemIngredients WHERE MenuID = {inputmenuid}&#34;.format(inputmenuid=menuid)
    with db.engine.connect() as conn:
        conn.connection.cursor().execute(delete_menuitemingredients_query)
        conn.connection.commit()
    
    delete_menuitem_query = &#34;DELETE FROM menuitems WHERE MenuID = {inputmenuid}&#34;.format(inputmenuid=menuid)
    with db.engine.connect() as conn:
        conn.connection.cursor().execute(delete_menuitem_query)
        conn.connection.commit()
    
    return jsonify({&#34;message&#34;: &#34;Sucessfully deleted Menu item with menuid = {inputmenuid}&#34;.format(inputmenuid=menuid)})</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.MenuItems.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>GET method for retrieving menu item information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self): #GetMenuItem
    &#34;&#34;&#34;
    GET method for retrieving menu item information.
    &#34;&#34;&#34;
    with db.engine.connect() as conn:
        result = conn.execution_options(stream_results=True).execute(text(&#34;select * from menuitems&#34;))
        menuitemlist = []
        for row in result:
            menuitemlist.append({&#34;menuid&#34;:row.menuid, &#34;itemname&#34;:row.itemname, &#34;price&#34;:row.price, &#34;picturepath&#34;:row.picturepath})
    return jsonify(menuitemlist)</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.MenuItems.post"><code class="name flex">
<span>def <span class="ident">post</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>POST method for creating menu item information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(AddMenuItem_model, validate=False)
def post(self): #AddMenuItem
    &#34;&#34;&#34;
    POST method for creating menu item information.
    &#34;&#34;&#34;
    # print(&#34;GOT HERE&#34;)
    data = request.get_json()
    category = data.get(&#34;category&#34;)
    itemname = data.get(&#34;itemname&#34;)
    price = data.get(&#34;price&#34;)
    menuid = 0

    select_query = text(&#34;SELECT MENUID FROM MENUITEMS WHERE MENUID BETWEEN {lowerbound} AND {upperbound} ORDER BY MENUID DESC LIMIT 1;&#34;.format(lowerbound = category,upperbound = int(category) + 100))
    with db.engine.connect() as conn:
        result = conn.execution_options(stream_results=True).execute(select_query)
        for row in result:
            menuid = row.menuid + 1

    add_menu_item_query = text(&#34;INSERT INTO MenuItems (MenuID, ItemName, Price) VALUES ({inputmenuid}, &#39;{inputitemname}&#39;, {inputprice})&#34;.format(inputmenuid=menuid, inputitemname=itemname, inputprice=price))
    try:
        with db.engine.connect() as conn:
            conn.execute(add_menu_item_query)
            conn.commit()
    except Exception as e:
        # print(e)
        return jsonify({&#34;message&#34;: &#34;Failed to add menu item&#34;})
    
    return jsonify({&#34;message&#34;: &#34;Sucessfully added Menu item with menuid = {inputmenuid}&#34;.format(inputmenuid=menuid)})</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.MenuItems.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>PUT method for updating menu item information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(UpdateMenuItem_model, validate=True)
def put(self): #UpdateMenuItem
    &#34;&#34;&#34;
    PUT method for updating menu item information.
    &#34;&#34;&#34;
    data = request.get_json()
    menuid = data.get(&#34;menuid&#34;)
    itemname = data.get(&#34;itemname&#34;)
    price = data.get(&#34;price&#34;)

    if (menuid == 0):
        return jsonify({&#34;message&#34;: &#34;No Menu Item ID entered. No query executed.&#34;})
    elif (itemname == &#34;string&#34; and price == 0):
        return jsonify({&#34;message&#34;: &#34;No inputs entered. No query executed.&#34;})
    
    update_query = &#34;UPDATE menuitems SET &#34;
    if (itemname != &#34;string&#34;):
        update_query += &#34;itemname = &#39;{inputnewname}&#39;,&#34;.format(inputnewname=itemname)
    if (price &gt; 0):
        update_query += &#34;price = {inputnewprice},&#34;.format(inputnewprice=price)

    update_query = update_query[:-1]
    update_query += &#34; WHERE menuid = {inputmenuidid}&#34;.format(inputmenuidid=menuid)

    with db.engine.connect() as conn:
        result = conn.execute(text(update_query))
        conn.commit()
    return jsonify({&#34;message&#34;: &#34;successful update of menu item with menuid = {inputmenuid}&#34;.format(inputmenuid=menuid)})</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.OrderHistory"><code class="flex name class">
<span>class <span class="ident">OrderHistory</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Resource for retrieving order history information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/orderhistory&#39;)
class OrderHistory(Resource):
    &#34;&#34;&#34;
    Resource for retrieving order history information.
    &#34;&#34;&#34;
    def get(self):
        &#34;&#34;&#34;
        GET method for retrieving order history information.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            limit_query = &#34;LIMIT 100&#34;
            get_order_query = &#34;SELECT * FROM orders {inputquery}&#34;.format(inputquery=limit_query)
            result = conn.execution_options(stream_results=True).execute(text(get_order_query))
            orderlist = []
            for row in result:
                orderlist.append({&#34;orderid&#34;:row.orderid, &#34;customername&#34;:row.customername, &#34;taxprice&#34;:row.taxprice,&#34;baseprice&#34;:row.baseprice,&#34;orderdatetime&#34;:row.orderdatetime,&#34;employeeid&#34;:row.employeeid})
        return jsonify(orderlist)
    
    @api.expect(UpdateOrder_model, validate=True)
    def put(self): 
        &#34;&#34;&#34;
        PUT method for updating order history information.
        &#34;&#34;&#34;
        orderid = request.get_json().get(&#34;orderid&#34;) 
        customername = request.get_json().get(&#34;customername&#34;)
        baseprice = request.get_json().get(&#34;baseprice&#34;) 
        employeeid = request.get_json().get(&#34;employeeid&#34;) 

        if (orderid == 0):
            return jsonify({&#34;message&#34;: &#34;No orderid entered. No query executed.&#34;})
        elif (customername == &#34;string&#34; and baseprice == 0 and employeeid == 0): 
            return jsonify({&#34;message&#34;: &#34;No inputs entered. No query executed.&#34;})
        
        update_order_query = &#34;UPDATE orders SET &#34;
        if (customername != &#34;string&#34;):
            update_order_query += &#34;CustomerName = &#39;{inputcustomername}&#39;,&#34;.format(inputcustomername=customername)
        if (baseprice &gt; 0):
            taxprice = baseprice*0.0825
            update_order_query += &#34;baseprice = {inputbaseprice}, taxprice = {inputtaxprice},&#34;.format(inputbaseprice=baseprice, inputtaxprice=taxprice)
        if (employeeid &gt; 0):
            update_order_query += &#34;employeeID = {inputemployeeid},&#34;.format(inputemployeeid=employeeid)
        update_order_query = update_order_query[:-1]
        update_order_query += &#34; WHERE orderid = {inputorderid}&#34;.format(inputorderid=orderid)

        with db.engine.connect() as conn:
            result = conn.execute(text(update_order_query)) 
            conn.commit()
        return jsonify({&#34;message&#34;: &#34;Successfully updated order history with orderid = {inputorderid}.&#34;.format(inputorderid=orderid)})
    
    @api.expect(DeleteOrder_model, validate=True)
    def delete(self): 
        &#34;&#34;&#34;
        DELETE method for deleting order history information.
        &#34;&#34;&#34;
        orderid = request.get_json().get(&#34;orderid&#34;) #
        if (orderid &gt;= 0):
            delete_order_query = &#34;DELETE FROM Orders WHERE orderid = {inputorderid}&#34;.format(inputorderid = orderid)
        else: 
            #TODO: check for other ways to get failure
            return jsonify({&#34;message&#34;:&#34;failed to deleted order with orderid = {inputorderid}&#34;.format(inputorderid = orderid)})
        with db.engine.connect() as conn:
            result_cursor = conn.connection.cursor().execute(delete_order_query)
        
            conn.connection.commit()

            try:
                if (result_cursor is None):
                    return jsonify({&#34;message&#34;:&#34;successfully deleted order with orderid = {inputorderid}&#34;.format(inputorderid = orderid)})
            except:
                return jsonify({&#34;message&#34;:&#34;failed to deleted order with orderid = {inputorderid}&#34;.format(inputorderid = orderid)})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.OrderHistory.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.OrderHistory.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>DELETE method for deleting order history information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(DeleteOrder_model, validate=True)
def delete(self): 
    &#34;&#34;&#34;
    DELETE method for deleting order history information.
    &#34;&#34;&#34;
    orderid = request.get_json().get(&#34;orderid&#34;) #
    if (orderid &gt;= 0):
        delete_order_query = &#34;DELETE FROM Orders WHERE orderid = {inputorderid}&#34;.format(inputorderid = orderid)
    else: 
        #TODO: check for other ways to get failure
        return jsonify({&#34;message&#34;:&#34;failed to deleted order with orderid = {inputorderid}&#34;.format(inputorderid = orderid)})
    with db.engine.connect() as conn:
        result_cursor = conn.connection.cursor().execute(delete_order_query)
    
        conn.connection.commit()

        try:
            if (result_cursor is None):
                return jsonify({&#34;message&#34;:&#34;successfully deleted order with orderid = {inputorderid}&#34;.format(inputorderid = orderid)})
        except:
            return jsonify({&#34;message&#34;:&#34;failed to deleted order with orderid = {inputorderid}&#34;.format(inputorderid = orderid)})</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.OrderHistory.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>GET method for retrieving order history information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self):
    &#34;&#34;&#34;
    GET method for retrieving order history information.
    &#34;&#34;&#34;
    with db.engine.connect() as conn:
        limit_query = &#34;LIMIT 100&#34;
        get_order_query = &#34;SELECT * FROM orders {inputquery}&#34;.format(inputquery=limit_query)
        result = conn.execution_options(stream_results=True).execute(text(get_order_query))
        orderlist = []
        for row in result:
            orderlist.append({&#34;orderid&#34;:row.orderid, &#34;customername&#34;:row.customername, &#34;taxprice&#34;:row.taxprice,&#34;baseprice&#34;:row.baseprice,&#34;orderdatetime&#34;:row.orderdatetime,&#34;employeeid&#34;:row.employeeid})
    return jsonify(orderlist)</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.OrderHistory.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>PUT method for updating order history information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(UpdateOrder_model, validate=True)
def put(self): 
    &#34;&#34;&#34;
    PUT method for updating order history information.
    &#34;&#34;&#34;
    orderid = request.get_json().get(&#34;orderid&#34;) 
    customername = request.get_json().get(&#34;customername&#34;)
    baseprice = request.get_json().get(&#34;baseprice&#34;) 
    employeeid = request.get_json().get(&#34;employeeid&#34;) 

    if (orderid == 0):
        return jsonify({&#34;message&#34;: &#34;No orderid entered. No query executed.&#34;})
    elif (customername == &#34;string&#34; and baseprice == 0 and employeeid == 0): 
        return jsonify({&#34;message&#34;: &#34;No inputs entered. No query executed.&#34;})
    
    update_order_query = &#34;UPDATE orders SET &#34;
    if (customername != &#34;string&#34;):
        update_order_query += &#34;CustomerName = &#39;{inputcustomername}&#39;,&#34;.format(inputcustomername=customername)
    if (baseprice &gt; 0):
        taxprice = baseprice*0.0825
        update_order_query += &#34;baseprice = {inputbaseprice}, taxprice = {inputtaxprice},&#34;.format(inputbaseprice=baseprice, inputtaxprice=taxprice)
    if (employeeid &gt; 0):
        update_order_query += &#34;employeeID = {inputemployeeid},&#34;.format(inputemployeeid=employeeid)
    update_order_query = update_order_query[:-1]
    update_order_query += &#34; WHERE orderid = {inputorderid}&#34;.format(inputorderid=orderid)

    with db.engine.connect() as conn:
        result = conn.execute(text(update_order_query)) 
        conn.commit()
    return jsonify({&#34;message&#34;: &#34;Successfully updated order history with orderid = {inputorderid}.&#34;.format(inputorderid=orderid)})</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.OrderStatusCanceled"><code class="flex name class">
<span>class <span class="ident">OrderStatusCanceled</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines API routes for updating the status of canceled orders managed by managers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/orderstatuscanceled&#39;)
class OrderStatusCanceled(Resource):
    &#34;&#34;&#34;
    Defines API routes for updating the status of canceled orders managed by managers.
    &#34;&#34;&#34;
    @api.expect(OrderStatus_model, validate=True)
    def put(self): 
        &#34;&#34;&#34;
        PUT method for updating the status of an order to &#39;canceled&#39;.
        &#34;&#34;&#34;
        orderid = request.get_json().get(&#34;orderid&#34;) 

        if (orderid == 0):
            return jsonify({&#34;message&#34;: &#34;No orderid entered. No query executed.&#34;})
        
        update_order_query = &#34;UPDATE orders SET orderstat = &#39;canceled&#39; where orderid = {inputorderid}&#34;.format(inputorderid=orderid)
        
        with db.engine.connect() as conn:
            conn.execute(text(update_order_query)) 
            conn.commit()
        return jsonify({&#34;message&#34;: &#34;Set order status to CANCELED for orderid = {inputorderid}.&#34;.format(inputorderid=orderid)})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.OrderStatusCanceled.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.OrderStatusCanceled.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>PUT method for updating the status of an order to 'canceled'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(OrderStatus_model, validate=True)
def put(self): 
    &#34;&#34;&#34;
    PUT method for updating the status of an order to &#39;canceled&#39;.
    &#34;&#34;&#34;
    orderid = request.get_json().get(&#34;orderid&#34;) 

    if (orderid == 0):
        return jsonify({&#34;message&#34;: &#34;No orderid entered. No query executed.&#34;})
    
    update_order_query = &#34;UPDATE orders SET orderstat = &#39;canceled&#39; where orderid = {inputorderid}&#34;.format(inputorderid=orderid)
    
    with db.engine.connect() as conn:
        conn.execute(text(update_order_query)) 
        conn.commit()
    return jsonify({&#34;message&#34;: &#34;Set order status to CANCELED for orderid = {inputorderid}.&#34;.format(inputorderid=orderid)})</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.OrderStatusCompleted"><code class="flex name class">
<span>class <span class="ident">OrderStatusCompleted</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines API routes for updating the status of completed orders managed by managers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/orderstatuscompleted&#39;)
class OrderStatusCompleted(Resource):
    &#34;&#34;&#34;
    Defines API routes for updating the status of completed orders managed by managers.
    &#34;&#34;&#34;
    @api.expect(OrderStatus_model, validate=True)
    def put(self): 
        &#34;&#34;&#34;
        PUT method for updating the status of an order to &#39;completed&#39;.
        &#34;&#34;&#34;
        orderid = request.get_json().get(&#34;orderid&#34;) 

        if (orderid == 0):
            return jsonify({&#34;message&#34;: &#34;No orderid entered. No query executed.&#34;})
        
        update_order_query = &#34;UPDATE orders SET orderstat = &#39;completed&#39; where orderid = {inputorderid}&#34;.format(inputorderid=orderid)
        
        with db.engine.connect() as conn:
            conn.execute(text(update_order_query)) 
            conn.commit()
        return jsonify({&#34;message&#34;: &#34;Set order status to COMPLETED for orderid = {inputorderid}.&#34;.format(inputorderid=orderid)})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.OrderStatusCompleted.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.OrderStatusCompleted.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>PUT method for updating the status of an order to 'completed'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(OrderStatus_model, validate=True)
def put(self): 
    &#34;&#34;&#34;
    PUT method for updating the status of an order to &#39;completed&#39;.
    &#34;&#34;&#34;
    orderid = request.get_json().get(&#34;orderid&#34;) 

    if (orderid == 0):
        return jsonify({&#34;message&#34;: &#34;No orderid entered. No query executed.&#34;})
    
    update_order_query = &#34;UPDATE orders SET orderstat = &#39;completed&#39; where orderid = {inputorderid}&#34;.format(inputorderid=orderid)
    
    with db.engine.connect() as conn:
        conn.execute(text(update_order_query)) 
        conn.commit()
    return jsonify({&#34;message&#34;: &#34;Set order status to COMPLETED for orderid = {inputorderid}.&#34;.format(inputorderid=orderid)})</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.OrderStatusDeleted"><code class="flex name class">
<span>class <span class="ident">OrderStatusDeleted</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines API routes for updating the status of deleted orders managed by managers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/orderstatusdeleted&#39;)
class OrderStatusDeleted(Resource):
    &#34;&#34;&#34;
    Defines API routes for updating the status of deleted orders managed by managers.
    &#34;&#34;&#34;
    @api.expect(OrderStatus_model, validate=True)
    def put(self): 
        &#34;&#34;&#34;
        PUT method for updating the status of an order to &#39;deleted&#39;.
        &#34;&#34;&#34;
        orderid = request.get_json().get(&#34;orderid&#34;) 

        if (orderid == 0):
            return jsonify({&#34;message&#34;: &#34;No orderid entered. No query executed.&#34;})
        
        update_order_query = &#34;UPDATE orders SET orderstat = &#39;deleted&#39; where orderid = {inputorderid}&#34;.format(inputorderid=orderid)
        
        with db.engine.connect() as conn:
            conn.execute(text(update_order_query)) 
            conn.commit()
        return jsonify({&#34;message&#34;: &#34;Set order status to DELETED for orderid = {inputorderid}.&#34;.format(inputorderid=orderid)})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.OrderStatusDeleted.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.OrderStatusDeleted.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>PUT method for updating the status of an order to 'deleted'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(OrderStatus_model, validate=True)
def put(self): 
    &#34;&#34;&#34;
    PUT method for updating the status of an order to &#39;deleted&#39;.
    &#34;&#34;&#34;
    orderid = request.get_json().get(&#34;orderid&#34;) 

    if (orderid == 0):
        return jsonify({&#34;message&#34;: &#34;No orderid entered. No query executed.&#34;})
    
    update_order_query = &#34;UPDATE orders SET orderstat = &#39;deleted&#39; where orderid = {inputorderid}&#34;.format(inputorderid=orderid)
    
    with db.engine.connect() as conn:
        conn.execute(text(update_order_query)) 
        conn.commit()
    return jsonify({&#34;message&#34;: &#34;Set order status to DELETED for orderid = {inputorderid}.&#34;.format(inputorderid=orderid)})</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.OrderStatusInprogress"><code class="flex name class">
<span>class <span class="ident">OrderStatusInprogress</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines API routes for updating the status of in-progress orders managed by managers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/orderstatusinprogress&#39;)
class OrderStatusInprogress(Resource):
    &#34;&#34;&#34;
    Defines API routes for updating the status of in-progress orders managed by managers.
    &#34;&#34;&#34;
    @api.expect(OrderStatus_model, validate=True)
    def put(self): 
        &#34;&#34;&#34;
        PUT method for updating the status of an order to &#39;inprogress&#39;.
        &#34;&#34;&#34;
        orderid = request.get_json().get(&#34;orderid&#34;) 

        if (orderid == 0):
            return jsonify({&#34;message&#34;: &#34;No orderid entered. No query executed.&#34;})
        
        update_order_query = &#34;UPDATE orders SET orderstat = &#39;inprogress&#39; where orderid = {inputorderid}&#34;.format(inputorderid=orderid)
        
        with db.engine.connect() as conn:
            conn.execute(text(update_order_query)) 
            conn.commit()
        return jsonify({&#34;message&#34;: &#34;Set order status to INPROGRESS for orderid = {inputorderid}.&#34;.format(inputorderid=orderid)})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.OrderStatusInprogress.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.OrderStatusInprogress.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>PUT method for updating the status of an order to 'inprogress'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(OrderStatus_model, validate=True)
def put(self): 
    &#34;&#34;&#34;
    PUT method for updating the status of an order to &#39;inprogress&#39;.
    &#34;&#34;&#34;
    orderid = request.get_json().get(&#34;orderid&#34;) 

    if (orderid == 0):
        return jsonify({&#34;message&#34;: &#34;No orderid entered. No query executed.&#34;})
    
    update_order_query = &#34;UPDATE orders SET orderstat = &#39;inprogress&#39; where orderid = {inputorderid}&#34;.format(inputorderid=orderid)
    
    with db.engine.connect() as conn:
        conn.execute(text(update_order_query)) 
        conn.commit()
    return jsonify({&#34;message&#34;: &#34;Set order status to INPROGRESS for orderid = {inputorderid}.&#34;.format(inputorderid=orderid)})</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.RestockAll"><code class="flex name class">
<span>class <span class="ident">RestockAll</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines API routes for restocking all ingredients below the recommended amount.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/restockall&#39;)
class RestockAll(Resource):
    &#34;&#34;&#34;
    Defines API routes for restocking all ingredients below the recommended amount.
    &#34;&#34;&#34;
    def get(self): #get all that needs to be restocked
        &#34;&#34;&#34;
        GET method for retrieving all ingredients that need to be restocked.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            get_stmt = &#34;select * from ingredients where count &lt; recommendedamount&#34;
            result = conn.execution_options(stream_results=True).execute(text(get_stmt))
            # ingrdientlist = []
            restocklist = []
            for row in result:
                # print(str(row))
                casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
                stockincrease = casestobuy*row.caseamount
                restocklist.append({&#34;message&#34;:&#34;Need &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory not affected. No restock occurred.&#34;})
            conn.connection.commit()
            if (len(restocklist) == 0):
                return jsonify({&#34;message&#34;: &#34;No inventory is below recommended amount.&#34;})
                # ingrdientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount, &#34;caseamount&#34;:row.caseamount})
        # return jsonify(ingrdientlist)
        return jsonify(restocklist)
    
    # @api.expect(RestockAll_model, validate=True)
    def put(self): #&#34;update&#34; restock all
        &#34;&#34;&#34;
        PUT method for updating all ingredients that need to be restocked.
        &#34;&#34;&#34;
        with db.engine.connect() as conn:
            get_stmt = &#34;select * from ingredients where count &lt; recommendedamount&#34;
            result = conn.execution_options(stream_results=True).execute(text(get_stmt))
            # ingrdientlist = []
            restocklist = []
            upIng = &#39;&#39;
            logIng = &#39;&#39;
            for row in result:
                # print(str(row))
                casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
                stockincrease = casestobuy*row.caseamount
                logMessage = &#39;RESTOCK ALL: BOUGHT {x} CASES FOR INGREDIENTID = {y}&#39;.format(x=casestobuy,y=row.ingredientid)
                upIng += &#34;UPDATE Ingredients SET Count = Count + &#34;+ str(stockincrease) + &#34; WHERE IngredientID = &#34; + str(row.ingredientid) + &#34;; &#34;
                logIng += &#34;INSERT INTO InventoryLog (IngredientID, AmountChanged, LogMessage, LogDateTime) VALUES (&#34;+ str(row.ingredientid)+&#34;, &#34;+str(stockincrease)+&#34;, &#39;&#34;+logMessage+&#34;&#39;, NOW()); &#34;
                # restocklist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;casesbought&#34;:casestobuy,&#34;stockincrease&#34;:stockincrease,&#34;message&#34;:&#34;Inventory changed. Restock successfull.&#34;})
                restocklist.append({&#34;message&#34;:&#34;Ordered &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory changed. Restock successfull.&#34;})
            if (upIng == &#34;&#34; or logIng == &#34;&#34;):
                return jsonify({&#34;message&#34;: &#34;No inventory is below recommended amount. No query executed.&#34;})
            conn.connection.cursor().execute(upIng)
            conn.connection.cursor().execute(logIng)
            conn.connection.commit()
                # ingrdientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount, &#34;caseamount&#34;:row.caseamount})
        # return jsonify(ingrdientlist)
        return jsonify(restocklist)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.RestockAll.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.RestockAll.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>GET method for retrieving all ingredients that need to be restocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self): #get all that needs to be restocked
    &#34;&#34;&#34;
    GET method for retrieving all ingredients that need to be restocked.
    &#34;&#34;&#34;
    with db.engine.connect() as conn:
        get_stmt = &#34;select * from ingredients where count &lt; recommendedamount&#34;
        result = conn.execution_options(stream_results=True).execute(text(get_stmt))
        # ingrdientlist = []
        restocklist = []
        for row in result:
            # print(str(row))
            casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
            stockincrease = casestobuy*row.caseamount
            restocklist.append({&#34;message&#34;:&#34;Need &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory not affected. No restock occurred.&#34;})
        conn.connection.commit()
        if (len(restocklist) == 0):
            return jsonify({&#34;message&#34;: &#34;No inventory is below recommended amount.&#34;})
            # ingrdientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount, &#34;caseamount&#34;:row.caseamount})
    # return jsonify(ingrdientlist)
    return jsonify(restocklist)</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.RestockAll.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>PUT method for updating all ingredients that need to be restocked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put(self): #&#34;update&#34; restock all
    &#34;&#34;&#34;
    PUT method for updating all ingredients that need to be restocked.
    &#34;&#34;&#34;
    with db.engine.connect() as conn:
        get_stmt = &#34;select * from ingredients where count &lt; recommendedamount&#34;
        result = conn.execution_options(stream_results=True).execute(text(get_stmt))
        # ingrdientlist = []
        restocklist = []
        upIng = &#39;&#39;
        logIng = &#39;&#39;
        for row in result:
            # print(str(row))
            casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
            stockincrease = casestobuy*row.caseamount
            logMessage = &#39;RESTOCK ALL: BOUGHT {x} CASES FOR INGREDIENTID = {y}&#39;.format(x=casestobuy,y=row.ingredientid)
            upIng += &#34;UPDATE Ingredients SET Count = Count + &#34;+ str(stockincrease) + &#34; WHERE IngredientID = &#34; + str(row.ingredientid) + &#34;; &#34;
            logIng += &#34;INSERT INTO InventoryLog (IngredientID, AmountChanged, LogMessage, LogDateTime) VALUES (&#34;+ str(row.ingredientid)+&#34;, &#34;+str(stockincrease)+&#34;, &#39;&#34;+logMessage+&#34;&#39;, NOW()); &#34;
            # restocklist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;casesbought&#34;:casestobuy,&#34;stockincrease&#34;:stockincrease,&#34;message&#34;:&#34;Inventory changed. Restock successfull.&#34;})
            restocklist.append({&#34;message&#34;:&#34;Ordered &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory changed. Restock successfull.&#34;})
        if (upIng == &#34;&#34; or logIng == &#34;&#34;):
            return jsonify({&#34;message&#34;: &#34;No inventory is below recommended amount. No query executed.&#34;})
        conn.connection.cursor().execute(upIng)
        conn.connection.cursor().execute(logIng)
        conn.connection.commit()
            # ingrdientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount, &#34;caseamount&#34;:row.caseamount})
    # return jsonify(ingrdientlist)
    return jsonify(restocklist)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.RestockByLocation"><code class="flex name class">
<span>class <span class="ident">RestockByLocation</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines API routes for restocking ingredients below the recommended amount in a specified location.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/restockbylocation&#39;)
class RestockByLocation(Resource):
    &#34;&#34;&#34;
    Defines API routes for restocking ingredients below the recommended amount in a specified location.
    &#34;&#34;&#34;
    @api.expect(RestockByLocation_model, validate=True)
    def post(self): #get restock by location
        &#34;&#34;&#34;
        POST method for retrieving ingredients that need to be restocked from a specified location.
        &#34;&#34;&#34;
        location = request.get_json().get(&#34;location&#34;)
        # print(&#34;location: &#34;+str(location))
        if ((location != &#39;fridge&#39;) and (location != &#39;freezer&#39;) and (location != &#39;pantry&#39;)):
            return jsonify({&#34;message&#34;: &#34;Incorrect or no location entered. No query executed.&#34;})
        with db.engine.connect() as conn:
            get_stmt = &#34;select * from ingredients where count &lt; recommendedamount and location = &#39;{x}&#39;&#34;.format(x=location)
            result = conn.execution_options(stream_results=True).execute(text(get_stmt))
            restocklist = []
            for row in result:
                casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
                stockincrease = casestobuy*row.caseamount
                # restocklist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;casesbought&#34;:casestobuy,&#34;stockincrease&#34;:stockincrease,&#34;message&#34;:&#34;Inventory not affected. No restock occurred.&#34;})
                restocklist.append({&#34;message&#34;:&#34;Need &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory not affected. No restock occurred.&#34;})
            if (len(restocklist) == 0):
                return jsonify({&#34;message&#34;: &#34;No inventory in the location {x} is below recommended amount. No query executed.&#34;.format(x=location)})
        return jsonify(restocklist)

    @api.expect(RestockByLocation_model, validate=True)
    def put(self): #&#34;update&#34; restock by location
        &#34;&#34;&#34;
        PUT method for updating ingredients that need to be restocked from a specified location.
        &#34;&#34;&#34;
        location = request.get_json().get(&#34;location&#34;)
        # print(&#34;location: &#34;+str(location))
        if ((location != &#39;fridge&#39;) and (location != &#39;freezer&#39;) and (location != &#39;pantry&#39;)):
            return jsonify({&#34;message&#34;: &#34;Incorrect or no location entered. No query executed.&#34;})
        with db.engine.connect() as conn:
            get_stmt = &#34;select * from ingredients where count &lt; recommendedamount and location = &#39;{x}&#39;&#34;.format(x=location)
            result = conn.execution_options(stream_results=True).execute(text(get_stmt))
            # ingrdientlist = []
            upIng = &#39;&#39;
            logIng = &#39;&#39;
            restocklist = []
            for row in result:
                casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
                stockincrease = casestobuy*row.caseamount
                # restocklist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;casesbought&#34;:casestobuy,&#34;stockincrease&#34;:stockincrease,&#34;message&#34;:&#34;Inventory changed. Restock successfull.&#34;})
                restocklist.append({&#34;message&#34;:&#34;Ordered &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory changed. Restock successfull.&#34;})
                logMessage = &#34;RESTOCK FOR {z}: BOUGHT {x} CASES OF {y}&#34;.format(z=location,x=casestobuy,y=row.ingredientname)
                upIng += &#34;UPDATE Ingredients SET Count = Count + &#34;+ str(stockincrease) + &#34; WHERE IngredientID = &#34; + str(row.ingredientid) + &#34;; &#34;
                logIng += &#34;INSERT INTO InventoryLog (IngredientID, AmountChanged, LogMessage, LogDateTime) VALUES (&#34;+ str(row.ingredientid)+&#34;, &#34;+str(+stockincrease)+&#34;, &#39;&#34;+logMessage+&#34;&#39;, NOW()); &#34;
            if (len(restocklist) == 0):
                return jsonify({&#34;message&#34;: &#34;No inventory in the location {x} is below recommended amount. No query executed.&#34;.format(x=location)})
            conn.connection.cursor().execute(upIng)
            conn.connection.cursor().execute(logIng)
            conn.connection.commit()
                # ingrdientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount, &#34;caseamount&#34;:row.caseamount})
        # return jsonify(ingrdientlist)
        return jsonify(restocklist)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.RestockByLocation.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.RestockByLocation.post"><code class="name flex">
<span>def <span class="ident">post</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>POST method for retrieving ingredients that need to be restocked from a specified location.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(RestockByLocation_model, validate=True)
def post(self): #get restock by location
    &#34;&#34;&#34;
    POST method for retrieving ingredients that need to be restocked from a specified location.
    &#34;&#34;&#34;
    location = request.get_json().get(&#34;location&#34;)
    # print(&#34;location: &#34;+str(location))
    if ((location != &#39;fridge&#39;) and (location != &#39;freezer&#39;) and (location != &#39;pantry&#39;)):
        return jsonify({&#34;message&#34;: &#34;Incorrect or no location entered. No query executed.&#34;})
    with db.engine.connect() as conn:
        get_stmt = &#34;select * from ingredients where count &lt; recommendedamount and location = &#39;{x}&#39;&#34;.format(x=location)
        result = conn.execution_options(stream_results=True).execute(text(get_stmt))
        restocklist = []
        for row in result:
            casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
            stockincrease = casestobuy*row.caseamount
            # restocklist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;casesbought&#34;:casestobuy,&#34;stockincrease&#34;:stockincrease,&#34;message&#34;:&#34;Inventory not affected. No restock occurred.&#34;})
            restocklist.append({&#34;message&#34;:&#34;Need &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory not affected. No restock occurred.&#34;})
        if (len(restocklist) == 0):
            return jsonify({&#34;message&#34;: &#34;No inventory in the location {x} is below recommended amount. No query executed.&#34;.format(x=location)})
    return jsonify(restocklist)</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.RestockByLocation.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>PUT method for updating ingredients that need to be restocked from a specified location.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(RestockByLocation_model, validate=True)
def put(self): #&#34;update&#34; restock by location
    &#34;&#34;&#34;
    PUT method for updating ingredients that need to be restocked from a specified location.
    &#34;&#34;&#34;
    location = request.get_json().get(&#34;location&#34;)
    # print(&#34;location: &#34;+str(location))
    if ((location != &#39;fridge&#39;) and (location != &#39;freezer&#39;) and (location != &#39;pantry&#39;)):
        return jsonify({&#34;message&#34;: &#34;Incorrect or no location entered. No query executed.&#34;})
    with db.engine.connect() as conn:
        get_stmt = &#34;select * from ingredients where count &lt; recommendedamount and location = &#39;{x}&#39;&#34;.format(x=location)
        result = conn.execution_options(stream_results=True).execute(text(get_stmt))
        # ingrdientlist = []
        upIng = &#39;&#39;
        logIng = &#39;&#39;
        restocklist = []
        for row in result:
            casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
            stockincrease = casestobuy*row.caseamount
            # restocklist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;casesbought&#34;:casestobuy,&#34;stockincrease&#34;:stockincrease,&#34;message&#34;:&#34;Inventory changed. Restock successfull.&#34;})
            restocklist.append({&#34;message&#34;:&#34;Ordered &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory changed. Restock successfull.&#34;})
            logMessage = &#34;RESTOCK FOR {z}: BOUGHT {x} CASES OF {y}&#34;.format(z=location,x=casestobuy,y=row.ingredientname)
            upIng += &#34;UPDATE Ingredients SET Count = Count + &#34;+ str(stockincrease) + &#34; WHERE IngredientID = &#34; + str(row.ingredientid) + &#34;; &#34;
            logIng += &#34;INSERT INTO InventoryLog (IngredientID, AmountChanged, LogMessage, LogDateTime) VALUES (&#34;+ str(row.ingredientid)+&#34;, &#34;+str(+stockincrease)+&#34;, &#39;&#34;+logMessage+&#34;&#39;, NOW()); &#34;
        if (len(restocklist) == 0):
            return jsonify({&#34;message&#34;: &#34;No inventory in the location {x} is below recommended amount. No query executed.&#34;.format(x=location)})
        conn.connection.cursor().execute(upIng)
        conn.connection.cursor().execute(logIng)
        conn.connection.commit()
            # ingrdientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount, &#34;caseamount&#34;:row.caseamount})
    # return jsonify(ingrdientlist)
    return jsonify(restocklist)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="revspos.manager_routes.RestockSome"><code class="flex name class">
<span>class <span class="ident">RestockSome</span></span>
<span>(</span><span>api=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines API routes for restocking specified ingredients below the recommended amount.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.route(&#39;/api/manager/restocksome&#39;)
class RestockSome(Resource):
    &#34;&#34;&#34;
    Defines API routes for restocking specified ingredients below the recommended amount.
    &#34;&#34;&#34;
    @api.expect(RestockSome_model, validate=True)
    def post(self): #get restock some
        &#34;&#34;&#34;
        POST method for retrieving ingredients that need to be restocked from a specified list.
        &#34;&#34;&#34;
        ingr_list = request.get_json().get(&#34;ingredientids&#34;, [])
        allingredients = &#34;&#34;
        for id in ingr_list:
            allingredients += &#34;ingredientid = &#34; + str(id) + &#34; or &#34;
        allingredients = allingredients[:-3]
        allingredients += &#34;)&#34;
        # ingredientid = request.get_json().get(&#34;ingredientid&#34;) 
        with db.engine.connect() as conn:
            get_stmt = &#34;select * from ingredients where count &lt; recommendedamount and ({x}&#34;.format(x=allingredients)
            result = conn.execution_options(stream_results=True).execute(text(get_stmt))
            restocklist = []
            for row in result:
                casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
                stockincrease = casestobuy*row.caseamount
                # restocklist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;casesbought&#34;:casestobuy,&#34;stockincrease&#34;:stockincrease,&#34;message&#34;:&#34;Inventory not affected. No restock occurred.&#34;})
                restocklist.append({&#34;message&#34;:&#34;Need &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory not affected. No restock occurred.&#34;})
            if (len(restocklist) == 0):
                return jsonify({&#34;message&#34;: &#34;No inventory for any ingredients provided is below recommended amount. No query executed.&#34;})
                # ingrdientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount, &#34;caseamount&#34;:row.caseamount})
        # return jsonify(ingrdientlist)
        return jsonify(restocklist)
    
    @api.expect(RestockSome_model, validate=True)
    def put(self): #&#34;update&#34; restock some
        &#34;&#34;&#34;
        PUT method for updating ingredients that need to be restocked from a specified list.
        &#34;&#34;&#34;
        ingr_list = request.get_json().get(&#34;ingredientids&#34;, [])
        allingredients = &#34;&#34;
        for id in ingr_list:
            allingredients += &#34;ingredientid = &#34; + str(id) + &#34; or &#34;
        allingredients = allingredients[:-3]
        allingredients += &#34;)&#34;
        # ingredientid = request.get_json().get(&#34;ingredientid&#34;) 
        with db.engine.connect() as conn:
            get_stmt = &#34;select * from ingredients where count &lt; recommendedamount and ({x}&#34;.format(x=allingredients)
            result = conn.execution_options(stream_results=True).execute(text(get_stmt))
            # ingrdientlist = []
            upIng = &#39;&#39;
            logIng = &#39;&#39;
            restocklist = []
            for row in result:
                casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
                stockincrease = casestobuy*row.caseamount
                # restocklist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;casesbought&#34;:casestobuy,&#34;stockincrease&#34;:stockincrease,&#34;message&#34;:&#34;Inventory changed. Restock successfull.&#34;})
                restocklist.append({&#34;message&#34;:&#34;Ordered &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory changed. Restock successfull.&#34;})
                logMessage = &#39;RESTOCK SOME: BOUGHT {x} CASES OF {y}&#39;.format(x=casestobuy,y=row.ingredientname)
                upIng += &#34;UPDATE Ingredients SET Count = Count + &#34;+ str(stockincrease) + &#34; WHERE IngredientID = &#34; + str(row.ingredientid) + &#34;; &#34;
                logIng += &#34;INSERT INTO InventoryLog (IngredientID, AmountChanged, LogMessage, LogDateTime) VALUES (&#34;+ str(row.ingredientid)+&#34;, &#34;+str(+stockincrease)+&#34;, &#39;&#34;+logMessage+&#34;&#39;, NOW()); &#34;
            
            if (len(restocklist) == 0):
                return jsonify({&#34;message&#34;: &#34;No inventory for any ingredients provided is below recommended amount. No query executed.&#34;})
            conn.connection.cursor().execute(upIng)
            conn.connection.cursor().execute(logIng)
            conn.connection.commit()
                # ingrdientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount, &#34;caseamount&#34;:row.caseamount})
        # return jsonify(ingrdientlist)
        return jsonify(restocklist)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>flask_restx.resource.Resource</li>
<li>flask.views.MethodView</li>
<li>flask.views.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="revspos.manager_routes.RestockSome.methods"><code class="name">var <span class="ident">methods</span> :Â ClassVar[Optional[Collection[str]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="revspos.manager_routes.RestockSome.post"><code class="name flex">
<span>def <span class="ident">post</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>POST method for retrieving ingredients that need to be restocked from a specified list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(RestockSome_model, validate=True)
def post(self): #get restock some
    &#34;&#34;&#34;
    POST method for retrieving ingredients that need to be restocked from a specified list.
    &#34;&#34;&#34;
    ingr_list = request.get_json().get(&#34;ingredientids&#34;, [])
    allingredients = &#34;&#34;
    for id in ingr_list:
        allingredients += &#34;ingredientid = &#34; + str(id) + &#34; or &#34;
    allingredients = allingredients[:-3]
    allingredients += &#34;)&#34;
    # ingredientid = request.get_json().get(&#34;ingredientid&#34;) 
    with db.engine.connect() as conn:
        get_stmt = &#34;select * from ingredients where count &lt; recommendedamount and ({x}&#34;.format(x=allingredients)
        result = conn.execution_options(stream_results=True).execute(text(get_stmt))
        restocklist = []
        for row in result:
            casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
            stockincrease = casestobuy*row.caseamount
            # restocklist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;casesbought&#34;:casestobuy,&#34;stockincrease&#34;:stockincrease,&#34;message&#34;:&#34;Inventory not affected. No restock occurred.&#34;})
            restocklist.append({&#34;message&#34;:&#34;Need &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory not affected. No restock occurred.&#34;})
        if (len(restocklist) == 0):
            return jsonify({&#34;message&#34;: &#34;No inventory for any ingredients provided is below recommended amount. No query executed.&#34;})
            # ingrdientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount, &#34;caseamount&#34;:row.caseamount})
    # return jsonify(ingrdientlist)
    return jsonify(restocklist)</code></pre>
</details>
</dd>
<dt id="revspos.manager_routes.RestockSome.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>PUT method for updating ingredients that need to be restocked from a specified list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@api.expect(RestockSome_model, validate=True)
def put(self): #&#34;update&#34; restock some
    &#34;&#34;&#34;
    PUT method for updating ingredients that need to be restocked from a specified list.
    &#34;&#34;&#34;
    ingr_list = request.get_json().get(&#34;ingredientids&#34;, [])
    allingredients = &#34;&#34;
    for id in ingr_list:
        allingredients += &#34;ingredientid = &#34; + str(id) + &#34; or &#34;
    allingredients = allingredients[:-3]
    allingredients += &#34;)&#34;
    # ingredientid = request.get_json().get(&#34;ingredientid&#34;) 
    with db.engine.connect() as conn:
        get_stmt = &#34;select * from ingredients where count &lt; recommendedamount and ({x}&#34;.format(x=allingredients)
        result = conn.execution_options(stream_results=True).execute(text(get_stmt))
        # ingrdientlist = []
        upIng = &#39;&#39;
        logIng = &#39;&#39;
        restocklist = []
        for row in result:
            casestobuy = int((row.recommendedamount - row.count) / row.caseamount) + 1
            stockincrease = casestobuy*row.caseamount
            # restocklist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;casesbought&#34;:casestobuy,&#34;stockincrease&#34;:stockincrease,&#34;message&#34;:&#34;Inventory changed. Restock successfull.&#34;})
            restocklist.append({&#34;message&#34;:&#34;Ordered &#34;+str(casestobuy)+&#34; cases for &#34;+str(stockincrease)+&#34; total units of ingredient &#34;+str(row.ingredientname)+&#34;. Inventory changed. Restock successfull.&#34;})
            logMessage = &#39;RESTOCK SOME: BOUGHT {x} CASES OF {y}&#39;.format(x=casestobuy,y=row.ingredientname)
            upIng += &#34;UPDATE Ingredients SET Count = Count + &#34;+ str(stockincrease) + &#34; WHERE IngredientID = &#34; + str(row.ingredientid) + &#34;; &#34;
            logIng += &#34;INSERT INTO InventoryLog (IngredientID, AmountChanged, LogMessage, LogDateTime) VALUES (&#34;+ str(row.ingredientid)+&#34;, &#34;+str(+stockincrease)+&#34;, &#39;&#34;+logMessage+&#34;&#39;, NOW()); &#34;
        
        if (len(restocklist) == 0):
            return jsonify({&#34;message&#34;: &#34;No inventory for any ingredients provided is below recommended amount. No query executed.&#34;})
        conn.connection.cursor().execute(upIng)
        conn.connection.cursor().execute(logIng)
        conn.connection.commit()
            # ingrdientlist.append({&#34;ingredientid&#34;:row.ingredientid, &#34;ingredientname&#34;:row.ingredientname, &#34;ppu&#34;:row.ppu,&#34;count&#34;:row.count,&#34;minamount&#34;:row.minamount,&#34;location&#34;:row.location,&#34;recommendedamount&#34;:row.recommendedamount, &#34;caseamount&#34;:row.caseamount})
    # return jsonify(ingrdientlist)
    return jsonify(restocklist)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="revspos" href="index.html">revspos</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="revspos.manager_routes.init" href="#revspos.manager_routes.init">init</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="revspos.manager_routes.CompleteOrder" href="#revspos.manager_routes.CompleteOrder">CompleteOrder</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.CompleteOrder.methods" href="#revspos.manager_routes.CompleteOrder.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.CompleteOrder.post" href="#revspos.manager_routes.CompleteOrder.post">post</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.Employee" href="#revspos.manager_routes.Employee">Employee</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.Employee.delete" href="#revspos.manager_routes.Employee.delete">delete</a></code></li>
<li><code><a title="revspos.manager_routes.Employee.get" href="#revspos.manager_routes.Employee.get">get</a></code></li>
<li><code><a title="revspos.manager_routes.Employee.methods" href="#revspos.manager_routes.Employee.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.Employee.post" href="#revspos.manager_routes.Employee.post">post</a></code></li>
<li><code><a title="revspos.manager_routes.Employee.put" href="#revspos.manager_routes.Employee.put">put</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.GenerateExcessReport" href="#revspos.manager_routes.GenerateExcessReport">GenerateExcessReport</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.GenerateExcessReport.methods" href="#revspos.manager_routes.GenerateExcessReport.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.GenerateExcessReport.post" href="#revspos.manager_routes.GenerateExcessReport.post">post</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.GenerateOrderTrend" href="#revspos.manager_routes.GenerateOrderTrend">GenerateOrderTrend</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.GenerateOrderTrend.methods" href="#revspos.manager_routes.GenerateOrderTrend.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.GenerateOrderTrend.post" href="#revspos.manager_routes.GenerateOrderTrend.post">post</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.GenerateProductUsage" href="#revspos.manager_routes.GenerateProductUsage">GenerateProductUsage</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.GenerateProductUsage.methods" href="#revspos.manager_routes.GenerateProductUsage.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.GenerateProductUsage.post" href="#revspos.manager_routes.GenerateProductUsage.post">post</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.GenerateRestockReport" href="#revspos.manager_routes.GenerateRestockReport">GenerateRestockReport</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.GenerateRestockReport.get" href="#revspos.manager_routes.GenerateRestockReport.get">get</a></code></li>
<li><code><a title="revspos.manager_routes.GenerateRestockReport.methods" href="#revspos.manager_routes.GenerateRestockReport.methods">methods</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.GenerateSalesReport" href="#revspos.manager_routes.GenerateSalesReport">GenerateSalesReport</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.GenerateSalesReport.methods" href="#revspos.manager_routes.GenerateSalesReport.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.GenerateSalesReport.post" href="#revspos.manager_routes.GenerateSalesReport.post">post</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.GetInProgressOrders" href="#revspos.manager_routes.GetInProgressOrders">GetInProgressOrders</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.GetInProgressOrders.get" href="#revspos.manager_routes.GetInProgressOrders.get">get</a></code></li>
<li><code><a title="revspos.manager_routes.GetInProgressOrders.methods" href="#revspos.manager_routes.GetInProgressOrders.methods">methods</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.Ingredients" href="#revspos.manager_routes.Ingredients">Ingredients</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.Ingredients.delete" href="#revspos.manager_routes.Ingredients.delete">delete</a></code></li>
<li><code><a title="revspos.manager_routes.Ingredients.get" href="#revspos.manager_routes.Ingredients.get">get</a></code></li>
<li><code><a title="revspos.manager_routes.Ingredients.methods" href="#revspos.manager_routes.Ingredients.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.Ingredients.post" href="#revspos.manager_routes.Ingredients.post">post</a></code></li>
<li><code><a title="revspos.manager_routes.Ingredients.put" href="#revspos.manager_routes.Ingredients.put">put</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.MenuItemCustomizations" href="#revspos.manager_routes.MenuItemCustomizations">MenuItemCustomizations</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.MenuItemCustomizations.delete" href="#revspos.manager_routes.MenuItemCustomizations.delete">delete</a></code></li>
<li><code><a title="revspos.manager_routes.MenuItemCustomizations.methods" href="#revspos.manager_routes.MenuItemCustomizations.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.MenuItemCustomizations.post" href="#revspos.manager_routes.MenuItemCustomizations.post">post</a></code></li>
<li><code><a title="revspos.manager_routes.MenuItemCustomizations.put" href="#revspos.manager_routes.MenuItemCustomizations.put">put</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.MenuItemIngredients" href="#revspos.manager_routes.MenuItemIngredients">MenuItemIngredients</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.MenuItemIngredients.delete" href="#revspos.manager_routes.MenuItemIngredients.delete">delete</a></code></li>
<li><code><a title="revspos.manager_routes.MenuItemIngredients.methods" href="#revspos.manager_routes.MenuItemIngredients.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.MenuItemIngredients.post" href="#revspos.manager_routes.MenuItemIngredients.post">post</a></code></li>
<li><code><a title="revspos.manager_routes.MenuItemIngredients.put" href="#revspos.manager_routes.MenuItemIngredients.put">put</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.MenuItems" href="#revspos.manager_routes.MenuItems">MenuItems</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.MenuItems.delete" href="#revspos.manager_routes.MenuItems.delete">delete</a></code></li>
<li><code><a title="revspos.manager_routes.MenuItems.get" href="#revspos.manager_routes.MenuItems.get">get</a></code></li>
<li><code><a title="revspos.manager_routes.MenuItems.methods" href="#revspos.manager_routes.MenuItems.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.MenuItems.post" href="#revspos.manager_routes.MenuItems.post">post</a></code></li>
<li><code><a title="revspos.manager_routes.MenuItems.put" href="#revspos.manager_routes.MenuItems.put">put</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.OrderHistory" href="#revspos.manager_routes.OrderHistory">OrderHistory</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.OrderHistory.delete" href="#revspos.manager_routes.OrderHistory.delete">delete</a></code></li>
<li><code><a title="revspos.manager_routes.OrderHistory.get" href="#revspos.manager_routes.OrderHistory.get">get</a></code></li>
<li><code><a title="revspos.manager_routes.OrderHistory.methods" href="#revspos.manager_routes.OrderHistory.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.OrderHistory.put" href="#revspos.manager_routes.OrderHistory.put">put</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.OrderStatusCanceled" href="#revspos.manager_routes.OrderStatusCanceled">OrderStatusCanceled</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.OrderStatusCanceled.methods" href="#revspos.manager_routes.OrderStatusCanceled.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.OrderStatusCanceled.put" href="#revspos.manager_routes.OrderStatusCanceled.put">put</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.OrderStatusCompleted" href="#revspos.manager_routes.OrderStatusCompleted">OrderStatusCompleted</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.OrderStatusCompleted.methods" href="#revspos.manager_routes.OrderStatusCompleted.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.OrderStatusCompleted.put" href="#revspos.manager_routes.OrderStatusCompleted.put">put</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.OrderStatusDeleted" href="#revspos.manager_routes.OrderStatusDeleted">OrderStatusDeleted</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.OrderStatusDeleted.methods" href="#revspos.manager_routes.OrderStatusDeleted.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.OrderStatusDeleted.put" href="#revspos.manager_routes.OrderStatusDeleted.put">put</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.OrderStatusInprogress" href="#revspos.manager_routes.OrderStatusInprogress">OrderStatusInprogress</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.OrderStatusInprogress.methods" href="#revspos.manager_routes.OrderStatusInprogress.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.OrderStatusInprogress.put" href="#revspos.manager_routes.OrderStatusInprogress.put">put</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.RestockAll" href="#revspos.manager_routes.RestockAll">RestockAll</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.RestockAll.get" href="#revspos.manager_routes.RestockAll.get">get</a></code></li>
<li><code><a title="revspos.manager_routes.RestockAll.methods" href="#revspos.manager_routes.RestockAll.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.RestockAll.put" href="#revspos.manager_routes.RestockAll.put">put</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.RestockByLocation" href="#revspos.manager_routes.RestockByLocation">RestockByLocation</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.RestockByLocation.methods" href="#revspos.manager_routes.RestockByLocation.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.RestockByLocation.post" href="#revspos.manager_routes.RestockByLocation.post">post</a></code></li>
<li><code><a title="revspos.manager_routes.RestockByLocation.put" href="#revspos.manager_routes.RestockByLocation.put">put</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="revspos.manager_routes.RestockSome" href="#revspos.manager_routes.RestockSome">RestockSome</a></code></h4>
<ul class="">
<li><code><a title="revspos.manager_routes.RestockSome.methods" href="#revspos.manager_routes.RestockSome.methods">methods</a></code></li>
<li><code><a title="revspos.manager_routes.RestockSome.post" href="#revspos.manager_routes.RestockSome.post">post</a></code></li>
<li><code><a title="revspos.manager_routes.RestockSome.put" href="#revspos.manager_routes.RestockSome.put">put</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>